// ARINC653 includes
#include "arinc653_core.h"

// Core #0 vector table
portUINTBASE PORT_VECTORTABLE_CORE0[PORT_VECTORTABLE_SIZE] = {
/*LDR PC, [PC, #0x18]*/(portUINTBASE) 0xE59FF018,
/*LDR PC, [PC, #0x18]*/(portUINTBASE) 0xE59FF018,
/*LDR PC, [PC, #0x18]*/(portUINTBASE) 0xE59FF018,
/*LDR PC, [PC, #0x18]*/(portUINTBASE) 0xE59FF018,
/*LDR PC, [PC, #0x14]*/(portUINTBASE) 0xE59FF014,
/*SUB PC, PC, #0x08*/(portUINTBASE) 0xE24FF008,
/*LDR PC, [PC, #0x10]*/(portUINTBASE) 0xE59FF010,
/*LDR PC, [PC, #0x10]*/(portUINTBASE) 0xE59FF010,
/*Reset handler*/(portUINTBASE) PORT_RESETHANDLER,
/*Undefined instruction handler*/(portUINTBASE) PORT_UNDEFINEDINSTRUCTIONHANDLER,
/*SVC handler*/(portUINTBASE) PORT_SVCHANDLER,
/*Abort handler*/(portUINTBASE) PORT_ABORTHANDLER,
/*IRQ handler*/(portUINTBASE) PORT_IRQHANDLER,
/*FIQ handler*/(portUINTBASE) PORT_FIQHANDLER,
/*NULL*/(portUINTBASE) null,
/*NULL*/(portUINTBASE) null };

// Prepare global FL translation table method
static portBOOLEAN PORT_PREPAREGLOBALFLTRANSLATIONTABLE(portUINTBASE **PTR_FLTRANSLATIONTABLE) {
	PORT_SYSTEM_CONFIGURATION_TYPE *PORT_SYSTEM_CONFIGURATION;
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	MODULE_CONFIGURATION_TYPE *MODULE_CONFIGURATION;
	PORT_MODULE_CONFIGURATION_TYPE *PORT_MODULE_CONFIGURATION;
	portUINTBASE UINT_ACCESS;

	// Gets port system configuration
	PORT_SYSTEM_CONFIGURATION = (PORT_SYSTEM_CONFIGURATION_TYPE *) SYSTEM_CONFIGURATION.PORT_SYSTEM_CONFIGURATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets module configuration
	MODULE_CONFIGURATION = _CURRENT_MODULE_INFORMATION->MODULE_CONFIGURATION;

	// Gets port module configuration
	PORT_MODULE_CONFIGURATION = (PORT_MODULE_CONFIGURATION_TYPE *) MODULE_CONFIGURATION->PORT_MODULE_CONFIGURATION;

	// Allocates/clears FL translation table
	if (!MMU_FLTRANSLATIONTABLE_ALLOCATE(PTR_FLTRANSLATIONTABLE)) {
		return false;
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_NO; // Vector table - Exceptions may occur in any context

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps vector table region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PORT_MODULE_CONFIGURATION->VECTORTABLE_ADDRESS, (portUINTBASE) ((portUINTBASE) PORT_MODULE_CONFIGURATION->VECTORTABLE_ADDRESS + PORT_MODULE_CONFIGURATION->VECTORTABLE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WT_NOWA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_GLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access to peripherals from any context

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps peripherals region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PORT_SYSTEM_CONFIGURATION->PERIPHERALS_ADDRESS, (portUINTBASE) ((portUINTBASE) PORT_SYSTEM_CONFIGURATION->PERIPHERALS_ADDRESS + PORT_SYSTEM_CONFIGURATION->PERIPHERALS_SIZE), MMU_MEMORYTYPE_DEVICE_SHAREABLE, MMU_CACHEPOLICY_NONCACHEABLE, MMU_CACHEPOLICY_NONCACHEABLE, MMU_SHAREABILITY_SHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_GLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Success
	return true;
}

// Context
#define CONTEXT_MODULEDEFAULTPARTITION 0
#define CONTEXT_MODULEHMCALLBACK 1
#define CONTEXT_PARTITIONDEFAULTPROCESS 2
#define CONTEXT_PARTITIONERRORHANDLER 3
#define CONTEXT_PARTITIONHMCALLBACK 4
#define CONTEXT_PROCESS 5

// Prepare non-global FL translation table method
static portBOOLEAN PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(portUINTBASE **PTR_FLTRANSLATIONTABLE, portUINTBASE UINT_CONTEXT, PARTITION_INFORMATION_TYPE *CONTEXT_PARTITION_INFORMATION, PROCESS_INFORMATION_TYPE *CONTEXT_PROCESS_INFORMATION) {
	SYSTEM_CONFIGURATION_TYPE *SYSTEM_CONFIGURATION;
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	MODULE_CONFIGURATION_TYPE *MODULE_CONFIGURATION;
	PORT_MODULE_CONFIGURATION_TYPE *PORT_MODULE_CONFIGURATION;
	INDEX_TYPE PARTITIONINDEX;
	PARTITION_CONFIGURATION_TYPE *PARTITION_CONFIGURATION;
	INDEX_TYPE PROCESSINDEX;
	PROCESS_CONFIGURATION_TYPE *PROCESS_CONFIGURATION;
	BOOLEAN_TYPE BOOL_ISSYSTEMPARTITIONCONTEXT;
	BOOLEAN_TYPE BOOL_ISOWNERPARTITION;
	BOOLEAN_TYPE BOOL_ISOWNERPROCESS;
	portUINTBASE UINT_ACCESS;

	// Gets system configuration
	SYSTEM_CONFIGURATION = SYSTEM_INFORMATION.SYSTEM_CONFIGURATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets module configuration
	MODULE_CONFIGURATION = _CURRENT_MODULE_INFORMATION->MODULE_CONFIGURATION;

	// Gets port module configuration
	PORT_MODULE_CONFIGURATION = (PORT_MODULE_CONFIGURATION_TYPE *) MODULE_CONFIGURATION->PORT_MODULE_CONFIGURATION;

	// Verifies system partition context
	BOOL_ISSYSTEMPARTITIONCONTEXT = (CONTEXT_PARTITION_INFORMATION != null ? CONTEXT_PARTITION_INFORMATION->PARTITION_ATTRIBUTE->SYSTEMPARTITION : false);

	// Allocates/clears FL translation table
	if (!MMU_FLTRANSLATIONTABLE_ALLOCATE(PTR_FLTRANSLATIONTABLE)) {
		return false;
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO; // Any context runs system code

	// Verifies debug state
#ifdef DEBUG
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW; // Debugging depends on this
#endif

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps system code region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) SYSTEM_CONFIGURATION->SYSTEM_CODE_ADDRESS, (portUINTBASE) ((portUINTBASE) SYSTEM_CONFIGURATION->SYSTEM_CODE_ADDRESS + SYSTEM_CONFIGURATION->SYSTEM_CODE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_SHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Accessed from system code

	// Verifies system partition context
	if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
	}

	// Verifies debug state
#ifdef DEBUG
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // For enabling console access
#endif

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps system data region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) SYSTEM_CONFIGURATION->SYSTEM_DATA_ADDRESS, (portUINTBASE) ((portUINTBASE) SYSTEM_CONFIGURATION->SYSTEM_DATA_ADDRESS + SYSTEM_CONFIGURATION->SYSTEM_DATA_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_NONCACHEABLE, MMU_SHAREABILITY_SHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Exceptions run in module stack
	switch (UINT_CONTEXT) {
	case CONTEXT_MODULEDEFAULTPARTITION:
		// Module default partition runs in module stack
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
		break;
	}

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module stack region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) MODULE_CONFIGURATION->MODULE_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) MODULE_CONFIGURATION->MODULE_STACK_ADDRESS + MODULE_CONFIGURATION->MODULE_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = null;
	switch (UINT_CONTEXT) {
	case CONTEXT_MODULEDEFAULTPARTITION:
		// Runs module code
		UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
		break;
	case CONTEXT_MODULEHMCALLBACK:
		// Code is located at module code
		UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
		break;
	}

	// Verifies debug state
#ifdef DEBUG
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW; // Debugging depends on this
#endif

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module code region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) MODULE_CONFIGURATION->MODULE_CODE_ADDRESS, (portUINTBASE) ((portUINTBASE) MODULE_CONFIGURATION->MODULE_CODE_ADDRESS + MODULE_CONFIGURATION->MODULE_CODE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Accessed from system code
	switch (UINT_CONTEXT) {
	case CONTEXT_MODULEDEFAULTPARTITION:
		// Runs module code
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
		break;
	case CONTEXT_MODULEHMCALLBACK:
		// Runs module code
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
		break;
	}

	// Verifies system partition context
	if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
	}

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module data region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) MODULE_CONFIGURATION->MODULE_DATA_ADDRESS, (portUINTBASE) ((portUINTBASE) MODULE_CONFIGURATION->MODULE_DATA_ADDRESS + MODULE_CONFIGURATION->MODULE_DATA_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	// Verifies measure state
#ifdef MEASURE
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Accessed from application to obtain context identifiers
#else
	UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Accessed from system code
#endif

	// Verifies system partition context
	if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
	}

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module heap region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) MODULE_CONFIGURATION->MODULE_HEAP_ADDRESS, (portUINTBASE) ((portUINTBASE) MODULE_CONFIGURATION->MODULE_HEAP_ADDRESS + MODULE_CONFIGURATION->MODULE_HEAP_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = null;
	switch (UINT_CONTEXT) {
	case CONTEXT_MODULEDEFAULTPARTITION:
		// Prepares translation tables for partitions
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	case CONTEXT_PARTITIONDEFAULTPROCESS:
		// Prepares translation tables for processes
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	case CONTEXT_PROCESS:
		// May be used to prepare translation tables in system partitions
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	}

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module FL translation table region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_FLTRANSLATIONTABLE_ADDRESS, (portUINTBASE) ((portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_FLTRANSLATIONTABLE_ADDRESS + PORT_MODULE_CONFIGURATION->MODULE_FLTRANSLATIONTABLE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WT_NOWA, MMU_CACHEPOLICY_WT_NOWA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Sets access
	UINT_ACCESS = null;
	switch (UINT_CONTEXT) {
	case CONTEXT_MODULEDEFAULTPARTITION:
		// Prepares translation tables for partitions
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	case CONTEXT_PARTITIONDEFAULTPROCESS:
		// Prepares translation tables for processes
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	case CONTEXT_PROCESS:
		// May be used to prepare translation tables in system partitions
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
		break;
	}

	// Verifies access
	if (UINT_ACCESS != null) {

		// Maps module SL translation table region
		if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_SLTRANSLATIONTABLE_ADDRESS, (portUINTBASE) ((portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_SLTRANSLATIONTABLE_ADDRESS + PORT_MODULE_CONFIGURATION->MODULE_SLTRANSLATIONTABLE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WT_NOWA, MMU_CACHEPOLICY_WT_NOWA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
			return false;
		}
	}

	// Verifies module HM callback stack
	if (MODULE_CONFIGURATION->MODULE_HMCALLBACK_STACK_ADDRESS != null) {

		// Sets access
		UINT_ACCESS = null;
		switch (UINT_CONTEXT) {
		case CONTEXT_MODULEHMCALLBACK:
			// Runs in module HM callback stack
			UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			break;
		}

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps module HM callback stack region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) MODULE_CONFIGURATION->MODULE_HMCALLBACK_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) MODULE_CONFIGURATION->MODULE_HMCALLBACK_STACK_ADDRESS + MODULE_CONFIGURATION->MODULE_HMCALLBACK_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}
	}

	// Iterates partitions
	for (PARTITIONINDEX = 0; PARTITIONINDEX < MODULE_CONFIGURATION->PARTITION_CONFIGURATION_SIZE; PARTITIONINDEX++) {

		// Gets partition configuration
		PARTITION_CONFIGURATION = &MODULE_CONFIGURATION->PARTITION_CONFIGURATION[PARTITIONINDEX];

		// Verifies owner partition
		BOOL_ISOWNERPARTITION = (CONTEXT_PARTITION_INFORMATION != null ? (PARTITION_CONFIGURATION == CONTEXT_PARTITION_INFORMATION->PARTITION_CONFIGURATION ? true : false) : false);

		// Sets access
		UINT_ACCESS = null;
		switch (UINT_CONTEXT) {
		case CONTEXT_PARTITIONDEFAULTPROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Runs partition code
				UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
			}
			break;
		case CONTEXT_PARTITIONERRORHANDLER:
			if (BOOL_ISOWNERPARTITION) {
				// Code is located at partition code
				UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
			}
			break;
		case CONTEXT_PARTITIONHMCALLBACK:
			if (BOOL_ISOWNERPARTITION) {
				// Code is located at partition code
				UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
			}
			break;
		case CONTEXT_PROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Code is located at partition code
				UINT_ACCESS = MMU_ACCESS_PL1_RO_PL0_RO;
			}
			break;
		}

		// Verifies debug state
#ifdef DEBUG
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW; // Debugging depends on this
#endif

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps partition code region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_CODE_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_CODE_ADDRESS + PARTITION_CONFIGURATION->PARTITION_CODE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}

		// Sets access
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Accessed from system code
		switch (UINT_CONTEXT) {
		case CONTEXT_PARTITIONDEFAULTPROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Runs partition code
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PARTITIONERRORHANDLER:
			if (BOOL_ISOWNERPARTITION) {
				// Data is located at partition data
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PARTITIONHMCALLBACK:
			if (BOOL_ISOWNERPARTITION) {
				// Data is located at partition data
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Data is located at partition data
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		}

		// Verifies system partition context
		if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
			UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
		}

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps partition data region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DATA_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DATA_ADDRESS + PARTITION_CONFIGURATION->PARTITION_DATA_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}

		// Sets access
		UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER; // Accessed from system code

		// Verifies system partition context
		if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
			UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
		}

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps partition data image region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DATA_IMAGE_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DATA_IMAGE_ADDRESS + PARTITION_CONFIGURATION->PARTITION_DATA_IMAGE_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}

		// Sets access
		UINT_ACCESS = null;
		switch (UINT_CONTEXT) {
		case CONTEXT_PARTITIONDEFAULTPROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Accessed from system code
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PARTITIONERRORHANDLER:
			if (BOOL_ISOWNERPARTITION) {
				// Accessed from system code
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PARTITIONHMCALLBACK:
			if (BOOL_ISOWNERPARTITION) {
				// Accessed from system code
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		case CONTEXT_PROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Accessed from system code
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		}

		// Verifies system partition context
		if (BOOL_ISSYSTEMPARTITIONCONTEXT) {
			UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER; // Free access for system partitions
		}

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps partition heap region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_HEAP_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_HEAP_ADDRESS + PARTITION_CONFIGURATION->PARTITION_HEAP_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}

		// Sets access
		UINT_ACCESS = null;
		switch (UINT_CONTEXT) {
		case CONTEXT_PARTITIONDEFAULTPROCESS:
			if (BOOL_ISOWNERPARTITION) {
				// Runs in partition default process stack
				UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
			}
			break;
		}

		// Verifies access
		if (UINT_ACCESS != null) {

			// Maps partition default process stack region
			if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DEFAULTPROCESS_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_DEFAULTPROCESS_STACK_ADDRESS + PARTITION_CONFIGURATION->PARTITION_DEFAULTPROCESS_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
				return false;
			}
		}

		// Verifies partition error handler stack
		if (PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_ADDRESS != null) {

			// Sets access
			UINT_ACCESS = null;
			switch (UINT_CONTEXT) {
			case CONTEXT_PARTITIONERRORHANDLER:
				if (BOOL_ISOWNERPARTITION) {
					// Runs in partition error handler stack
					UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
				}
				break;
			}

			// Verifies access
			if (UINT_ACCESS != null) {

				// Maps partition error handler stack region
				if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_ADDRESS + PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
					return false;
				}
			}
		}

		// Verifies partition HM callback stack
		if (PARTITION_CONFIGURATION->PARTITION_HMCALLBACK_STACK_ADDRESS != null) {

			// Sets access
			UINT_ACCESS = null;
			switch (UINT_CONTEXT) {
			case CONTEXT_PARTITIONHMCALLBACK:
				if (BOOL_ISOWNERPARTITION) {
					// Runs in partition HM callback stack
					UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
				}
				break;
			}

			// Verifies access
			if (UINT_ACCESS != null) {

				// Maps partition HM callback stack region
				if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PARTITION_CONFIGURATION->PARTITION_HMCALLBACK_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) PARTITION_CONFIGURATION->PARTITION_HMCALLBACK_STACK_ADDRESS + PARTITION_CONFIGURATION->PARTITION_HMCALLBACK_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
					return false;
				}
			}
		}

		// Iterates processes
		for (PROCESSINDEX = 0; PROCESSINDEX < PARTITION_CONFIGURATION->PROCESS_CONFIGURATION_SIZE; PROCESSINDEX++) {

			// Gets process configuration
			PROCESS_CONFIGURATION = &PARTITION_CONFIGURATION->PROCESS_CONFIGURATION[PROCESSINDEX];

			// Verifies owner process
			BOOL_ISOWNERPROCESS = (CONTEXT_PROCESS_INFORMATION != null ? (PROCESS_CONFIGURATION == CONTEXT_PROCESS_INFORMATION->PROCESS_CONFIGURATION ? true : false) : false);

			// Sets access
			UINT_ACCESS = null;
			switch (UINT_CONTEXT) {
			case CONTEXT_PROCESS:
				if (BOOL_ISOWNERPROCESS) {
					// Runs in process stack
					UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_RW | MMU_ACCESS_EXECUTENEVER;
				} else if (BOOL_ISOWNERPARTITION) {
					// Used for intrapartition communication optimization
					UINT_ACCESS = MMU_ACCESS_PL1_RW_PL0_NO | MMU_ACCESS_EXECUTENEVER;
				}
				break;
			}

			// Verifies access
			if (UINT_ACCESS != null) {

				// Maps process stack region
				if (!MMU_MAPREGION(*PTR_FLTRANSLATIONTABLE, (portUINTBASE) PROCESS_CONFIGURATION->PROCESS_STACK_ADDRESS, (portUINTBASE) ((portUINTBASE) PROCESS_CONFIGURATION->PROCESS_STACK_ADDRESS + PROCESS_CONFIGURATION->PROCESS_STACK_SIZE), MMU_MEMORYTYPE_NORMAL_CACHEABLE, MMU_CACHEPOLICY_WB_WA, MMU_CACHEPOLICY_WB_WA, MMU_SHAREABILITY_NONSHAREABLE, MMU_SECURITY_NONSECURE, MMU_SCOPE_NONGLOBAL, UINT_ACCESS)) {
					return false;
				}
			}
		}
	}

	// Success
	return true;
}

// Hook - STARTUP_SYSTEM
portBOOLEAN PORT_HOOK_STARTUP_SYSTEM(void) {

	// Initializes modules' configurations
	CORE_MODULE_INFORMATION[0].MODULE_CONFIGURATION = MODULE_CONFIGURATION_CORE0;

	// Initializes console
	if (!CONSOLE_STARTUP()) {
		return false;
	}

    // Initializes delay timer
    if (!TIMER_DELAY_STARTUP()) {
        return false;
    }

	// Success
	return true;
}

// Hook - RUN_SYSTEM
portBOOLEAN PORT_HOOK_RUN_SYSTEM(void) {

	// Runs system
	PORT_RUNSYSTEM();

	// Success
	return true;
}

// Hook - Before STARTUP_MODULE
portBOOLEAN PORT_HOOK_BEFORE_STARTUP_MODULE(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	MODULE_CONFIGURATION_TYPE *MODULE_CONFIGURATION;
	PORT_MODULE_CONFIGURATION_TYPE *PORT_MODULE_CONFIGURATION;
	INDEX_TYPE VECTORTABLEINDEX;
	portUINTBASE *VECTORTABLESOURCE;
	portUINTBASE *VECTORTABLEDESTINATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets module configuration
	MODULE_CONFIGURATION = _CURRENT_MODULE_INFORMATION->MODULE_CONFIGURATION;

	// Gets port module configuration
	PORT_MODULE_CONFIGURATION = (PORT_MODULE_CONFIGURATION_TYPE *) MODULE_CONFIGURATION->PORT_MODULE_CONFIGURATION;

	// Prepares vector table copy
	VECTORTABLESOURCE = (portUINTBASE *) PORT_VECTORTABLE_CORE0;
	VECTORTABLEDESTINATION = (portUINTBASE *) PORT_VECTORTABLE_ADDRESS_CORE0;

	// Copies vector table
	for (VECTORTABLEINDEX = 0; VECTORTABLEINDEX < PORT_VECTORTABLE_SIZE; VECTORTABLEINDEX++) {
		VECTORTABLEDESTINATION[VECTORTABLEINDEX] = VECTORTABLESOURCE[VECTORTABLEINDEX];
	}

	// Sets vector table base address
	CP15VectorBaseAddrSet(PORT_VECTORTABLE_ADDRESS_CORE0);

	// Initializes interrupt control
	IntAINTCInit();

	// Starts up MMU module
	MMU_STARTUP((portUINTBASE *) PORT_MODULE_CONFIGURATION->MODULE_FLTRANSLATIONTABLE_ADDRESS, (portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_FLTRANSLATIONTABLE_SIZE, (portUINTBASE *) PORT_MODULE_CONFIGURATION->MODULE_SLTRANSLATIONTABLE_ADDRESS, (portUINTBASE) PORT_MODULE_CONFIGURATION->MODULE_SLTRANSLATIONTABLE_SIZE);

	// Success
	return true;
}

// Hook - After STARTUP_MODULE
portBOOLEAN PORT_HOOK_AFTER_STARTUP_MODULE(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	MODULE_CONFIGURATION_TYPE *MODULE_CONFIGURATION;
	PORT_MODULE_CONFIGURATION_TYPE *PORT_MODULE_CONFIGURATION;
	portUINTBASE *PTR_FLTRANSLATIONTABLE;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets module configuration
	MODULE_CONFIGURATION = _CURRENT_MODULE_INFORMATION->MODULE_CONFIGURATION;

	// Gets port module configuration
	PORT_MODULE_CONFIGURATION = (PORT_MODULE_CONFIGURATION_TYPE *) MODULE_CONFIGURATION->PORT_MODULE_CONFIGURATION;

	// Prepares global FL translation table
	{

		// Gets module global FL translation table address
		PTR_FLTRANSLATIONTABLE = PORT_MODULE_CONFIGURATION->MODULE_GLOBAL_FLTRANSLATIONTABLE_ADDRESS;

		// Prepares global FL translation table
		if (!PORT_PREPAREGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE)) {
			return false;
		}

		// Sets module global FL translation table address
		PORT_MODULE_CONFIGURATION->MODULE_GLOBAL_FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
	}

	// Prepares module default partition context
	{

		// Gets module default partition FL translation table address
		PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

		// Prepares non-global FL translation table
		if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_MODULEDEFAULTPARTITION, null, null)) {
			return false;
		}

		// Sets module default partition FL translation table address
		((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((MODULE_INFORMATION->CONTEXT.IDENTIFIER << 8) | (MODULE_INFORMATION->CONTEXT.IDENTIFIER << 0));
		((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
	}

	// Verifies module health monitoring callback existence
	if (MODULE_CONFIGURATION->MODULE_HMCALLBACK_STACK_ADDRESS != null) {

		// Prepares module health monitoring callback context
		{

			// Gets module health monitoring callback FL translation table address
			PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

			// Prepares non-global FL translation table
			if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_MODULEHMCALLBACK, null, null)) {
				return false;
			}

			// Sets module health monitoring callback FL translation table address
			((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER << 8) | (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER << 0));
			((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
		}
	}

	// Enables MMU
	MMU_ENABLE(PORT_MODULE_CONFIGURATION->MODULE_GLOBAL_FLTRANSLATIONTABLE_ADDRESS, ((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS, ((PORT_CONTEXT_TYPE *) MODULE_INFORMATION->CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER);

	// Exits privileged mode
	PORT_EXITPRIVILEGEDMODE();

	// Success
	return true;
}

// Hook - Before CREATE_PARTITION
portBOOLEAN PORT_HOOK_BEFORE_CREATE_PARTITION(portADDRESS PARTITION_INFORMATION_ADDRESS) {
	return true;
}

// Hook - After CREATE_PARTITION
portBOOLEAN PORT_HOOK_AFTER_CREATE_PARTITION(portADDRESS PARTITION_INFORMATION_ADDRESS) {
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;
	PARTITION_CONFIGURATION_TYPE *PARTITION_CONFIGURATION;
	portUINTBASE *PTR_FLTRANSLATIONTABLE;

	// Gets partition information
	PARTITION_INFORMATION = (PARTITION_INFORMATION_TYPE *) PARTITION_INFORMATION_ADDRESS;

	// Gets partition configuration
	PARTITION_CONFIGURATION = PARTITION_INFORMATION->PARTITION_CONFIGURATION;

	// Prepares partition default process context
	{

		// Gets partition default process FL translation table address
		PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

		// Prepares non-global FL translation table
		if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_PARTITIONDEFAULTPROCESS, PARTITION_INFORMATION, null)) {
			return false;
		}

		// Sets partition default process FL translation table address
		((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((PARTITION_INFORMATION->CONTEXT.IDENTIFIER << 8) | (PARTITION_INFORMATION->CONTEXT.IDENTIFIER << 0));
		((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
	}

	// Verifies partition health monitoring callback existence
	if (PARTITION_CONFIGURATION->PARTITION_HMCALLBACK_STACK_ADDRESS != null) {

		// Prepares partition health monitoring callback context
		{

			// Gets partition health monitoring callback FL translation table address
			PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

			// Prepares non-global FL translation table
			if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_PARTITIONHMCALLBACK, PARTITION_INFORMATION, null)) {
				return false;
			}

			// Sets partition health monitoring callback FL translation table address
			((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER << 8) | (PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER << 0));
			((PORT_CONTEXT_TYPE *) PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
		}
	}

	// Success
	return true;
}

// Hook - Before CREATE_PROCESS
portBOOLEAN PORT_HOOK_BEFORE_CREATE_PROCESS(portADDRESS PARTITION_INFORMATION_ADDRESS, portADDRESS PROCESS_INFORMATION_ADDRESS) {
	return true;
}

// Hook - After CREATE_PROCESS
portBOOLEAN PORT_HOOK_AFTER_CREATE_PROCESS(portADDRESS PARTITION_INFORMATION_ADDRESS, portADDRESS PROCESS_INFORMATION_ADDRESS) {
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;
	portUINTBASE *PTR_FLTRANSLATIONTABLE;

	// Gets partition information
	PARTITION_INFORMATION = (PARTITION_INFORMATION_TYPE *) PARTITION_INFORMATION_ADDRESS;

	// Gets process information
	PROCESS_INFORMATION = (PROCESS_INFORMATION_TYPE *) PROCESS_INFORMATION_ADDRESS;

	// Prepares process context
	{

		// Gets process FL translation table address
		PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) PROCESS_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

		// Prepares non-global FL translation table
		if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_PROCESS, PARTITION_INFORMATION, PROCESS_INFORMATION)) {
			return false;
		}

		// Sets process FL translation table address
		((PORT_CONTEXT_TYPE *) PROCESS_INFORMATION->CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((PROCESS_INFORMATION->CONTEXT.IDENTIFIER << 8) | (PROCESS_INFORMATION->CONTEXT.IDENTIFIER << 0));
		((PORT_CONTEXT_TYPE *) PROCESS_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
	}

	// Success
	return true;
}

// Hook - Before CREATE_ERROR_HANDLER
portBOOLEAN PORT_HOOK_BEFORE_CREATE_ERROR_HANDLER(portADDRESS PARTITION_INFORMATION_ADDRESS, portADDRESS ERRORHANDLER_INFORMATION_ADDRESS) {
	return true;
}

// Hook - After CREATE_ERROR_HANDLER
portBOOLEAN PORT_HOOK_AFTER_CREATE_ERROR_HANDLER(portADDRESS PARTITION_INFORMATION_ADDRESS, portADDRESS ERRORHANDLER_INFORMATION_ADDRESS) {
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;
	ERRORHANDLER_INFORMATION_TYPE *ERRORHANDLER_INFORMATION;
	portUINTBASE *PTR_FLTRANSLATIONTABLE;

	// Gets partition information
	PARTITION_INFORMATION = (PARTITION_INFORMATION_TYPE *) PARTITION_INFORMATION_ADDRESS;

	// Gets error handler information
	ERRORHANDLER_INFORMATION = (ERRORHANDLER_INFORMATION_TYPE *) ERRORHANDLER_INFORMATION_ADDRESS;

	// Prepares partition error handler context
	{

		// Gets partition error handler FL translation table address
		PTR_FLTRANSLATIONTABLE = ((PORT_CONTEXT_TYPE *) ERRORHANDLER_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS;

		// Prepares non-global FL translation table
		if (!PORT_PREPARENONGLOBALFLTRANSLATIONTABLE(&PTR_FLTRANSLATIONTABLE, CONTEXT_PARTITIONERRORHANDLER, PARTITION_INFORMATION, null)) {
			return false;
		}

		// Sets partition error handler FL translation table address
		((PORT_CONTEXT_TYPE *) ERRORHANDLER_INFORMATION->CONTEXT.PORT_CONTEXT)->CONTEXT_IDENTIFIER = ((ERRORHANDLER_INFORMATION->CONTEXT.IDENTIFIER << 8) | (ERRORHANDLER_INFORMATION->CONTEXT.IDENTIFIER << 0));
		((PORT_CONTEXT_TYPE *) ERRORHANDLER_INFORMATION->CONTEXT.PORT_CONTEXT)->FLTRANSLATIONTABLE_ADDRESS = PTR_FLTRANSLATIONTABLE;
	}

	// Success
	return true;
}

// Tick initialization method
void PORT_INITIALIZETICK(void) {

	// Starts tick timer
	TIMER_TICK_STARTUP(PORT_TICK);
}

// Context identifier range getter - Determines the range of context identifiers that can be used by the current module
void PORT_GETCONTEXTIDENTIFIERRANGE(IDENTIFIER_TYPE *FIRST_CONTEXT_IDENTIFIER, IDENTIFIER_TYPE *LAST_CONTEXT_IDENTIFIER) {
	*FIRST_CONTEXT_IDENTIFIER = 1;
	*LAST_CONTEXT_IDENTIFIER = 254;
}

// Initialize context method - Initializes context in its creation time
void PORT_INITIALIZECONTEXT(CONTEXT_TYPE *CONTEXT) {
	PORT_CONTEXT_TYPE *PORT_CONTEXT;

	// Initializes context

	// Initializes port context

	// Gets port context
	PORT_CONTEXT = (PORT_CONTEXT_TYPE *) CONTEXT->PORT_CONTEXT;

	// Initializes run status registers
	PORT_CONTEXT->PC = null;
	PORT_CONTEXT->CPSR = null;

	// Initializes NEON/VFP coprocessor registers
	PORT_CONTEXT->D0 = null;
	PORT_CONTEXT->D1 = null;
	PORT_CONTEXT->D2 = null;
	PORT_CONTEXT->D3 = null;
	PORT_CONTEXT->D4 = null;
	PORT_CONTEXT->D5 = null;
	PORT_CONTEXT->D6 = null;
	PORT_CONTEXT->D7 = null;
	PORT_CONTEXT->D8 = null;
	PORT_CONTEXT->D9 = null;
	PORT_CONTEXT->D10 = null;
	PORT_CONTEXT->D11 = null;
	PORT_CONTEXT->D12 = null;
	PORT_CONTEXT->D13 = null;
	PORT_CONTEXT->D14 = null;
	PORT_CONTEXT->D15 = null;
	PORT_CONTEXT->D16 = null;
	PORT_CONTEXT->D17 = null;
	PORT_CONTEXT->D18 = null;
	PORT_CONTEXT->D19 = null;
	PORT_CONTEXT->D20 = null;
	PORT_CONTEXT->D21 = null;
	PORT_CONTEXT->D22 = null;
	PORT_CONTEXT->D23 = null;
	PORT_CONTEXT->D24 = null;
	PORT_CONTEXT->D25 = null;
	PORT_CONTEXT->D26 = null;
	PORT_CONTEXT->D27 = null;
	PORT_CONTEXT->D28 = null;
	PORT_CONTEXT->D29 = null;
	PORT_CONTEXT->D30 = null;
	PORT_CONTEXT->D31 = null;
	PORT_CONTEXT->FPSCR = null;
	PORT_CONTEXT->FPEXC = null;

	// Initializes general registers
	PORT_CONTEXT->R0 = null;
	PORT_CONTEXT->R1 = null;
	PORT_CONTEXT->R2 = null;
	PORT_CONTEXT->R3 = null;
	PORT_CONTEXT->R4 = null;
	PORT_CONTEXT->R5 = null;
	PORT_CONTEXT->R6 = null;
	PORT_CONTEXT->R7 = null;
	PORT_CONTEXT->R8 = null;
	PORT_CONTEXT->R9 = null;
	PORT_CONTEXT->R10 = null;
	PORT_CONTEXT->R11 = null;
	PORT_CONTEXT->R12 = null;
	PORT_CONTEXT->R13 = null;
	PORT_CONTEXT->R14 = null;

	// Initializes other information
	PORT_CONTEXT->CONTEXT_IDENTIFIER = null;
	PORT_CONTEXT->FLTRANSLATIONTABLE_ADDRESS = null;
}

// Prepare context method - Prepares context for running (called multiple times)
void PORT_PREPARECONTEXT(CONTEXT_TYPE *CONTEXT) {
	PORT_CONTEXT_TYPE *PORT_CONTEXT;

	// Initializes context

	// Initializes core depth
	CONTEXT->CORE_DEPTH = 0;

	// Initializes port context

	// Gets port context
	PORT_CONTEXT = (PORT_CONTEXT_TYPE *) CONTEXT->PORT_CONTEXT;

	// Initializes run status registers
	PORT_CONTEXT->PC = CONTEXT->ENTRY_POINT;
	if (CONTEXT->SYSTEM_PARTITION_CONTEXT) {
		PORT_CONTEXT->CPSR = 0x0000001F; // SYSTEM mode, ARM mode, interrupts enabled
	} else {
		PORT_CONTEXT->CPSR = 0x00000010; // USER mode, ARM mode, interrupts enabled
	}

	// Initializes NEON/VFP coprocessor registers
	PORT_CONTEXT->D0 = 0x0000000000000000;
	PORT_CONTEXT->D1 = 0x0000000000000000;
	PORT_CONTEXT->D2 = 0x0000000000000000;
	PORT_CONTEXT->D3 = 0x0000000000000000;
	PORT_CONTEXT->D4 = 0x0000000000000000;
	PORT_CONTEXT->D5 = 0x0000000000000000;
	PORT_CONTEXT->D6 = 0x0000000000000000;
	PORT_CONTEXT->D7 = 0x0000000000000000;
	PORT_CONTEXT->D8 = 0x0000000000000000;
	PORT_CONTEXT->D9 = 0x0000000000000000;
	PORT_CONTEXT->D10 = 0x0000000000000000;
	PORT_CONTEXT->D11 = 0x0000000000000000;
	PORT_CONTEXT->D12 = 0x0000000000000000;
	PORT_CONTEXT->D13 = 0x0000000000000000;
	PORT_CONTEXT->D14 = 0x0000000000000000;
	PORT_CONTEXT->D15 = 0x0000000000000000;
	PORT_CONTEXT->FPSCR = 0x00000000;
	PORT_CONTEXT->FPEXC = 0x40000000; // VFP/NEON enabled

	// Initializes general registers
	PORT_CONTEXT->R0 = CONTEXT->PARAMETER1;
	PORT_CONTEXT->R1 = CONTEXT->PARAMETER2;
	PORT_CONTEXT->R2 = 0x00000000;
	PORT_CONTEXT->R3 = 0x00000000;
	PORT_CONTEXT->R4 = 0x00000000;
	PORT_CONTEXT->R5 = 0x00000000;
	PORT_CONTEXT->R6 = 0x00000000;
	PORT_CONTEXT->R7 = 0x00000000;
	PORT_CONTEXT->R8 = 0x00000000;
	PORT_CONTEXT->R9 = 0x00000000;
	PORT_CONTEXT->R10 = 0x00000000;
	PORT_CONTEXT->R11 = 0x00000000;
	PORT_CONTEXT->R12 = 0x00000000;
	PORT_CONTEXT->R13 = (portUINT32) CONTEXT->STACK_TOP; // SP
	PORT_CONTEXT->R14 = (portUINT32) CONTEXT->RETURN_POINT; // LR

	// Initializes other information
	// PORT_CONTEXT->CONTEXT_IDENTIFIER = null; // Keeps allocated value
	// PORT_CONTEXT->FLTRANSLATIONTABLE_ADDRESS = null; // Keeps allocated value
}

// Tick termination method
void PORT_TERMINATETICK(void) {

	// Shuts down tick timer
	TIMER_TICK_SHUTDOWN();
}

// Module restarting method
void PORT_RESTARTMODULE(void) {

	// Disables interrupts
	PORT_DISABLEINTERRUPTS();

	// Resets the platform
	HWREG(SOC_PRM_DEVICE_REGS) = 0x00000002;
}

// Abort error handler fault status getter
static void PORT_ABORTERRORHANDLER_GETFAULTSTATUS(portUINTBASE FS, BOOLEAN_TYPE IN_STACK_AREA, ERROR_IDENTIFIER_TYPE *ERROR_IDENTIFIER, ERROR_CODE_TYPE *ERROR_CODE, MESSAGE_ADDR_TYPE *MESSAGE_ADDR, MESSAGE_SIZE_TYPE *MESSAGE_SIZE) {

	// Verifies fault status
	switch (FS) {
	case 3: //0b00011 - Access flag fault, first level
	case 5: //0b00101 - Translation fault, first level
	case 6: //0b00110 - Access flag fault, second level
	case 7: //0b00111 - Translation fault, second level
	case 13: //0b01101 - Permission fault, first level
	case 15: //0b01111 - Permission fault, second level
		*ERROR_IDENTIFIER = (IN_STACK_AREA ? ERRORIDENTIFIER_STACKOVERFLOW : ERRORIDENTIFIER_MEMORYVIOLATION);
		*ERROR_CODE = (IN_STACK_AREA ? STACK_OVERFLOW : MEMORY_VIOLATION);
		*MESSAGE_ADDR = (IN_STACK_AREA ? (MESSAGE_ADDR_TYPE) "STACK OVERFLOW" : (MESSAGE_ADDR_TYPE) "MEMORY VIOLATION");
		*MESSAGE_SIZE = (IN_STACK_AREA ? 14 : 16);
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		if (IN_STACK_AREA) {
			CONSOLE_PRINTF("Stack overflow (%u)", FS);
		} else {
			CONSOLE_PRINTF("Memory violation (%u)", FS);
		}
#endif
		break;
	case 26: //0b11010 - Coprocessor abort
		*ERROR_IDENTIFIER = ERRORIDENTIFIER_HARDWAREFAULT;
		*ERROR_CODE = HARDWARE_FAULT;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) "HARDWARE FAULT";
		*MESSAGE_SIZE = 14;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("Hardware fault (%u)", FS);
#endif
		break;
	case 9: //0b01001 - Domain fault, first level
	case 11: //0b01011 - Domain fault, second level
	case 16: //0b10000 - TLB conflict abort
	case 20: //0b10100 - Lockdown
		*ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) ERRORIDENTIFIER_TRANSLATIONFAULT;
		*ERROR_CODE = (ERROR_CODE_TYPE) null;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) "TRANSLATION FAULT";
		*MESSAGE_SIZE = 17;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("Translation fault (%u)", FS);
#endif
		break;
	case 1: //0b00001 - Alignment fault
		*ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) ERRORIDENTIFIER_MEMORYALIGNMENTFAULT;
		*ERROR_CODE = (ERROR_CODE_TYPE) null;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) "MEMORY ALIGNMENT FAULT";
		*MESSAGE_SIZE = 22;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("Memory alignment fault (%u)", FS);
#endif
		break;
	case 8: //0b01000 - Synchronous external abort
	case 12: //0b01100 - Synchronous external abort on translation table walk, first level
	case 14: //0b01110 - Synchronous external abort on translation table walk, second level
	case 22: //0b10110 - Asynchronous external abort
	case 24: //0b11000 - Asynchronous parity error on memory access
	case 25: //0b11001 - Synchronous parity error on memory access
	case 28: //0b11100 - Synchronous parity error on translation table walk, first level
	case 30: //0b11110 - Synchronous parity error on translation table walk, second level
		*ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) ERRORIDENTIFIER_MEMORYACCESSFAULT;
		*ERROR_CODE = (ERROR_CODE_TYPE) null;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) "MEMORY ACCESS FAULT";
		*MESSAGE_SIZE = 19;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("Memory access fault (%u)", FS);
#endif
		break;
	case 4: //0b00100 - Fault on instruction cache maintenance
		*ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) ERRORIDENTIFIER_CACHEFAULT;
		*ERROR_CODE = (ERROR_CODE_TYPE) null;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) "CACHE FAULT";
		*MESSAGE_SIZE = 11;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("Cache fault (%u)", FS);
#endif
		break;
	default:
		*ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) null;
		*ERROR_CODE = (ERROR_CODE_TYPE) null;
		*MESSAGE_ADDR = (MESSAGE_ADDR_TYPE) null;
		*MESSAGE_SIZE = 0;
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		CONSOLE_PRINTF("WARNING: Unhandled error (%u)", FS);
#endif
		break;
	}
}

// Abort error handler method
void PORT_ABORTERRORHANDLER(portUINTBASE DFAR, portUINTBASE DFSR, portUINTBASE IFAR, portUINTBASE IFSR, portUINTBASE LR) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	CONTEXT_TYPE *CURRENT_CONTEXT;
	CONTEXT_TYPE *NEXT_CONTEXT;
	portUINTBASE WnR;
	portUINTBASE FS;
	BOOLEAN_TYPE IN_STACK_AREA;
	BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT;
	PROCESS_ID_TYPE FAILED_PROCESS_ID;
	ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER;
	ERROR_CODE_TYPE ERROR_CODE;
	MESSAGE_ADDR_TYPE MESSAGE_ADDR;
	MESSAGE_SIZE_TYPE MESSAGE_SIZE;
	RETURN_CODE_TYPE RETURN_CODE;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets current context
	CURRENT_CONTEXT = _CORE_CURRENT_CONTEXT;

	// Gets next context
	NEXT_CONTEXT = _CORE_NEXT_CONTEXT;

#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
	// Shows current context
	CONSOLE_PRINTF("Current context (%u): ", CURRENT_CONTEXT->IDENTIFIER);

	// Verifies current system state
	switch (CURRENT_CONTEXT->SYSTEM_STATE) {
	case SYSTEMSTATE_MODULEHEALTHMONITORINGCALLBACK:
		CONSOLE_PRINTF("Module HM callback\n");
		break;
	case SYSTEMSTATE_MODULEDEFAULTPARTITION:
		CONSOLE_PRINTF("Module default partition\n");
		break;
	case SYSTEMSTATE_MODULEIDLEPARTITION:
		CONSOLE_PRINTF("Module idle partition\n");
		break;
	case SYSTEMSTATE_PARTITIONHEALTHMONITORINGCALLBACK:
		CONSOLE_PRINTF("Partition HM callback\n");
		break;
	case SYSTEMSTATE_PARTITIONERRORHANDLER:
		CONSOLE_PRINTF("Partition error handler\n");
		break;
	case SYSTEMSTATE_PARTITIONDEFAULTPROCESS:
		CONSOLE_PRINTF("Partition default process\n");
		break;
	case SYSTEMSTATE_PARTITIONIDLEPROCESS:
		CONSOLE_PRINTF("Partition idle process\n");
		break;
	case SYSTEMSTATE_PROCESS:
		CONSOLE_PRINTF("Process\n");
		break;
	case SYSTEMSTATE_OPERATINGSYSTEM:
		CONSOLE_PRINTF("Operating system\n");
		break;
	}

	// Verifies next context
	if (NEXT_CONTEXT != null) {

		// Shows next context
		CONSOLE_PRINTF("Next context (%u): ", NEXT_CONTEXT->IDENTIFIER);

		// Verifies next system state
		switch (NEXT_CONTEXT->SYSTEM_STATE) {
		case SYSTEMSTATE_MODULEHEALTHMONITORINGCALLBACK:
			CONSOLE_PRINTF("Module HM callback\n");
			break;
		case SYSTEMSTATE_MODULEDEFAULTPARTITION:
			CONSOLE_PRINTF("Module default partition\n");
			break;
		case SYSTEMSTATE_MODULEIDLEPARTITION:
			CONSOLE_PRINTF("Module idle partition\n");
			break;
		case SYSTEMSTATE_PARTITIONHEALTHMONITORINGCALLBACK:
			CONSOLE_PRINTF("Partition HM callback\n");
			break;
		case SYSTEMSTATE_PARTITIONERRORHANDLER:
			CONSOLE_PRINTF("Partition error handler\n");
			break;
		case SYSTEMSTATE_PARTITIONDEFAULTPROCESS:
			CONSOLE_PRINTF("Partition default process\n");
			break;
		case SYSTEMSTATE_PARTITIONIDLEPROCESS:
			CONSOLE_PRINTF("Partition idle process\n");
			break;
		case SYSTEMSTATE_PROCESS:
			CONSOLE_PRINTF("Process\n");
			break;
		case SYSTEMSTATE_OPERATINGSYSTEM:
			CONSOLE_PRINTF("Operating system\n");
			break;
		}
	}
#endif

	// Sets system partition context
	SYSTEM_PARTITION_CONTEXT = (_CURRENT_PARTITION_INFORMATION != null ? _CURRENT_PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT : false);

	// Sets failed process identifier
	FAILED_PROCESS_ID = (_CURRENT_PARTITION_INFORMATION != null ? (_CURRENT_PROCESS_INFORMATION != null ? _CURRENT_PROCESS_INFORMATION->IDENTIFIER : INVALID_IDENTIFIER) : INVALID_IDENTIFIER);

	// Verifies data fault in stack area
	IN_STACK_AREA = ((DFAR >= (portUINTBASE) ((PORT_SYSTEM_CONFIGURATION_TYPE *) SYSTEM_CONFIGURATION.PORT_SYSTEM_CONFIGURATION)->STACK_AREA_START_ADDRESS) && (DFAR < (portUINTBASE) ((PORT_SYSTEM_CONFIGURATION_TYPE *) SYSTEM_CONFIGURATION.PORT_SYSTEM_CONFIGURATION)->STACK_AREA_END_ADDRESS));

	// Handles prefetch abort
	if (IFSR != null) {

		// FaultStatus
		FS = ((IFSR & (1 << 10)) >> 6) | (IFSR & (0xF));

#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		// Shows abort type
		CONSOLE_PRINTF("Prefetch abort: ");
#endif

		// Gets fault status
		PORT_ABORTERRORHANDLER_GETFAULTSTATUS(FS, IN_STACK_AREA, &ERROR_IDENTIFIER, &ERROR_CODE, &MESSAGE_ADDR, &MESSAGE_SIZE);

#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		// Breaks line
		CONSOLE_PRINTF("\n");
#endif

		// Verifies error identifier
		if (ERROR_IDENTIFIER != null) {

			// Raises error
			RAISE_ERROR(false, false, SYSTEM_PARTITION_CONTEXT, CURRENT_CONTEXT->SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, MESSAGE_SIZE, FAILED_PROCESS_ID, (SYSTEM_ADDRESS_TYPE) LR, &RETURN_CODE);
		}
	}

	// Handles data abort
	if (DFSR != null) {

		// WriteNotRead
		WnR = (DFSR & (1 << 11)) >> 11;

		// FaultStatus
		FS = ((DFSR & (1 << 10)) >> 6) | (DFSR & (0xF));

#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
		// Shows abort type
		CONSOLE_PRINTF("Data abort: ");
#endif

		// Gets fault status
		PORT_ABORTERRORHANDLER_GETFAULTSTATUS(FS, IN_STACK_AREA, &ERROR_IDENTIFIER, &ERROR_CODE, &MESSAGE_ADDR, &MESSAGE_SIZE);

		// Verifies read/write
		if (WnR) {
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
			CONSOLE_PRINTF(" while writing 0x%X, running at 0x%X\n", DFAR, LR);
#endif
		} else {
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
			CONSOLE_PRINTF(" while reading 0x%X, running at 0x%X\n", DFAR, LR);
#endif
		}

		// Verifies error identifier
		if (ERROR_IDENTIFIER != null) {

			// Raises error
			RAISE_ERROR(false, false, SYSTEM_PARTITION_CONTEXT, CURRENT_CONTEXT->SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, MESSAGE_SIZE, FAILED_PROCESS_ID, (SYSTEM_ADDRESS_TYPE) LR, &RETURN_CODE);
		}
	}
}

// Undefined instruction error handler method
void PORT_UNDEFINEDINSTRUCTIONERRORHANDLER(portUINTBASE LR) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	CONTEXT_TYPE *CURRENT_CONTEXT;
	BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT;
	PROCESS_ID_TYPE FAILED_PROCESS_ID;
	RETURN_CODE_TYPE RETURN_CODE;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets current context
	CURRENT_CONTEXT = _CORE_CURRENT_CONTEXT;

	// Sets system partition context
	SYSTEM_PARTITION_CONTEXT = (_CURRENT_PARTITION_INFORMATION != null ? _CURRENT_PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT : false);

	// Sets failed process identifier
	FAILED_PROCESS_ID = (_CURRENT_PARTITION_INFORMATION != null ? (_CURRENT_PROCESS_INFORMATION != null ? _CURRENT_PROCESS_INFORMATION->IDENTIFIER : INVALID_IDENTIFIER) : INVALID_IDENTIFIER);

	// Raises error
	RAISE_ERROR(false, false, SYSTEM_PARTITION_CONTEXT, CURRENT_CONTEXT->SYSTEM_STATE, (ERROR_IDENTIFIER_TYPE) ERRORIDENTIFIER_UNDEFINEDINSTRUCTION, (ERROR_CODE_TYPE) null, (MESSAGE_ADDR_TYPE) "UNDEFINED INSTRUCTION", 21, FAILED_PROCESS_ID, (SYSTEM_ADDRESS_TYPE) LR, &RETURN_CODE);
#if PORT_GENERATECONSOLEOUTPUT_ERRORS == true
	CONSOLE_PRINTF("Undefined instruction (0x%X)\n", LR);
#endif
}

// Report system error method
void PORT_REPORTSYSTEMERROR(SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH) {

	// Must be used with caution and for debug purposes only, because causes jitter (is called with interrupts disabled)

#if defined(TRACK)
	CONSOLE_PRINTF("%u ERR SYS\n", TRACK_READ());
#elif PORT_GENERATECONSOLEOUTPUT_REPORTS == true
	// Prints to UART console
	CONSOLE_PRINTF("System error: ");
	CONSOLE_PUTS((char *) MESSAGE_ADDR, (int) LENGTH);
	CONSOLE_PRINTF(", system state %u, error identifier %u, error code %u\n", SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE);
#endif
}

// Report module error method
void PORT_REPORTMODULEERROR(SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH) {

	// Must be used with caution and for debug purposes only, because causes jitter (is called with interrupts disabled)

#if defined(TRACK)
	CONSOLE_PRINTF("%u ERR MOD\n", TRACK_READ());
#elif PORT_GENERATECONSOLEOUTPUT_REPORTS == true
	// Prints to UART console
	CONSOLE_PRINTF("Module error: ");
	CONSOLE_PUTS((char *) MESSAGE_ADDR, (int) LENGTH);
	CONSOLE_PRINTF(", system state %u, error identifier %u, error code %u\n", SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE);
#endif
}

// Report partition error method
void PORT_REPORTPARTITIONERROR(SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH) {

	// Must be used with caution and for debug purposes only, because causes jitter (is called with interrupts disabled)

#if defined(TRACK)
	CONSOLE_PRINTF("%u ERR PAR\n", TRACK_READ());
#elif PORT_GENERATECONSOLEOUTPUT_REPORTS == true
	// Prints to UART console
	CONSOLE_PRINTF("Partition error: ");
	CONSOLE_PUTS((char *) MESSAGE_ADDR, (int) LENGTH);
	CONSOLE_PRINTF(", system state %u, error identifier %u, error code %u\n", SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE);
#endif
}

// Report process error method
void PORT_REPORTPROCESSERROR(SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, PROCESS_ID_TYPE FAILED_PROCESS_ID, SYSTEM_ADDRESS_TYPE FAILED_ADDRESS) {

	// Must be used with caution and for debug purposes only, because causes jitter (is called with interrupts disabled)

#if defined(TRACK)
	CONSOLE_PRINTF("%u ERR PRO\n", TRACK_READ());
#elif PORT_GENERATECONSOLEOUTPUT_REPORTS == true
	// Prints to UART console
	CONSOLE_PRINTF("Process error: ");
	CONSOLE_PUTS((char *) MESSAGE_ADDR, (int) LENGTH);
	CONSOLE_PRINTF(", system state %u, error identifier %u, error code %u, failed process %u, failed address 0x%X\n", SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, FAILED_PROCESS_ID, FAILED_ADDRESS);
#endif
}

// Report application message method
void PORT_REPORTAPPLICATIONMESSAGE(MESSAGE_ADDR_TYPE MESSAGE_ADDR, MESSAGE_SIZE_TYPE LENGTH) {

	// Must be used with caution and for debug purposes only, because causes jitter (is called with interrupts disabled)

#if defined(TRACK)
	CONSOLE_PRINTF("%u ERR APP\n", TRACK_READ());
#elif PORT_GENERATECONSOLEOUTPUT_REPORTS == true
	// Prints to UART console
	CONSOLE_PRINTF("Application message: ");
	CONSOLE_PUTS((char *) MESSAGE_ADDR, (int) LENGTH);
	CONSOLE_PRINTF("\n");
#endif
}
