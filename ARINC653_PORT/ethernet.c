// Includes
#include "ethernet.h"

// Configurations
#define ETHERNET_MAXIMUM_INSTANCES 1
#define ETHERNET_MAXIMUM_INSTANCE_PORTS 1
#define ETHERNET_MDIO_INPUT_FREQUENCY 125000000
#define ETHERNET_MDIO_OUTPUT_FREQUENCY 1000000

// Definitions
#define ETHERNET_CPDMA_DEFAULTCHANNEL 0
#define ETHERNET_CPSW_DEFAULTCORE 0
#define ETHERNET_ALE_MAXIMUMENTRIES 1024

// CPDMA buffer descriptor
struct _ETHERNET_CPDMA_BUFFERDESCRIPTOR {
	volatile struct _ETHERNET_CPDMA_BUFFERDESCRIPTOR *NEXT;
	volatile unsigned int BUFFERPOINTER;
	volatile unsigned int BUFFEROFFSET_BUFFERLENGTH;
	volatile unsigned int FLAGS_PACKETLENGTH;
};
typedef struct _ETHERNET_CPDMA_BUFFERDESCRIPTOR ETHERNET_CPDMA_BUFFERDESCRIPTOR;

// CPDMA buffer descriptor memory definitions
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_SIZE 0x00002000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_DESCRIPTORCOUNT 512
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_TX_OFFSET 0x00000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_TX_DESCRIPTORCOUNT 256
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_RX_OFFSET 0x00001000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_RX_DESCRIPTORCOUNT 256

// CPDMA buffer descriptor TX definitions
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFEROFFSET_MASK 0xFFFF0000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFEROFFSET_SHIFT 16
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFERLENGTH_MASK 0x0000FFFF
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFERLENGTH_SHIFT 0
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_SOP_MASK 0x80000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_EOP_MASK 0x40000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_OWNERSHIP_MASK 0x20000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_EOQ_MASK 0x10000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TEARDOWNCOMPLETE_MASK 0x08000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_PASSCRC_MASK 0x04000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TOPORTENABLE_MASK 0x00100000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TOPORT_MASK 0x00030000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TOPORT_SHIFT 16
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_PACKETLENGTH_MASK 0x000007FF
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_PACKETLENGTH_SHIFT 0

// CPDMA buffer descriptor RX definitions
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFEROFFSET_MASK 0x07FF0000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFEROFFSET_SHIFT 16
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFERLENGTH_MASK 0x000007FF
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFERLENGTH_SHIFT 0
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SOP_MASK 0x80000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOP_MASK 0x40000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK 0x20000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOQ_MASK 0x10000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_TEARDOWNCOMPLETE_MASK 0x08000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_PASSEDCRC_MASK 0x04000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_LONG_MASK 0x02000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SHORT_MASK 0x01000000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_MACCONTROL_MASK 0x00800000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OVERRUN_MASK 0x00400000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_PACKETERROR_MASK 0x00300000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_PACKETERROR_SHIFT 20
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_RXVLANENCAPSULATE_MASK 0x00080000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_MASK 0x00070000
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_SHIFT 16
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_PACKETLENGTH_MASK 0x000007FF
#define ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_PACKETLENGTH_SHIFT 0

// CPSW port
struct _ETHERNET_CPSW_PORT {
	// Initialized flag
	unsigned char INITIALIZED;
	// Base addresses
	unsigned int BASEADDRESS_PORT;
	unsigned int BASEADDRESS_SLIVER;
	// Attributes
	unsigned int PHY_ADDRESS;
	unsigned char PHY_GIGABIT;
	// VLAN entries indexes
	unsigned int ALE_ENTRY_INDEX_VLANTABLE;
	unsigned int ALE_ENTRY_INDEX_VLANUNICASTADDRESSTABLE;
};
typedef struct _ETHERNET_CPSW_PORT ETHERNET_CPSW_PORT;

// CPSW instance
struct _ETHERNET_CPSW_INSTANCE {
	// Initialized flag
	unsigned char INITIALIZED;
	// Base addresses
	unsigned int BASEADDRESS_SS;
	unsigned int BASEADDRESS_MDIO;
	unsigned int BASEADDRESS_WR;
	unsigned int BASEADDRESS_CPDMA;
	unsigned int BASEADDRESS_ALE;
	unsigned int BASEADDRESS_STAT;
	unsigned int BASEADDRESS_HOSTPORT;
	unsigned int BASEADDRESS_CPPIRAM;
	// CPDMA TX free buffer descriptor queue
	unsigned int CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL;
	// CPDMA TX busy buffer descriptor queue
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL;
	// CPDMA RX buffer descriptor queue
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL;
	// Ports
	ETHERNET_CPSW_PORT CPSW_PORTS[ETHERNET_MAXIMUM_INSTANCE_PORTS];
};
typedef struct _ETHERNET_CPSW_INSTANCE ETHERNET_CPSW_INSTANCE;

// CPSW instances array
static ETHERNET_CPSW_INSTANCE ETHERNET_CPSW_INSTANCES[ETHERNET_MAXIMUM_INSTANCES];

// ALE entry format:
// -----------------------------------
// 00000000 00000000 00000000 00000000   WORD1
// 31                                0
// 00000000 00000000 00000000 00000000   WORD2
// 63                               32
//                            00000000   WORD3
//                            71    64
// -----------------------------------

// ALE entry
struct _ETHERNET_ALE_ENTRY {
	unsigned int WORD1; // Bits 31:00
	unsigned int WORD2; // Bits 63:32
	unsigned int WORD3; // Bits 71:64
};
typedef struct _ETHERNET_ALE_ENTRY ETHERNET_ALE_ENTRY;

// ALE entry general definitions
#define ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_MASK 0x30000000
#define ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT 28

// ALE entry general definitions - Entry type values
#define ETHERNET_ALE_ENTRY_ENTRYTYPE_FREEENTRY 0x00
#define ETHERNET_ALE_ENTRY_ENTRYTYPE_ADDRESSENTRY 0x01
#define ETHERNET_ALE_ENTRY_ENTRYTYPE_VLANENTRY 0x02
#define ETHERNET_ALE_ENTRY_ENTRYTYPE_VLANADDRESSENTRY 0x03

// ALE entry multicast address table entry definitions
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_MASK 0x0000001C
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_SHIFT 2
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_SUPER_MASK 0x00000002
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_SUPER_SHIFT 1
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_MASK 0xC0000000
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_SHIFT 30

// ALE entry multicast address table entry definitions - Port mask values
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_PORT0 0x01
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_PORT1 0x02
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_PORT2 0x04
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_HOSTPORT ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_PORT0
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_PORTMASK_SLAVEPORT(PORT) (0x01 << PORT)

// ALE entry multicast address table entry definitions - Supervisory packet values
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_SUPER_NONSUPERVISORY 0
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_SUPER_SUPERVISORY 1

// ALE entry multicast address table entry definitions - Multicast forward state values
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_BLOCKINGFORWARDINGLEARNING 0x01
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_FORWARDINGLEARNING 0x02
#define ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_FORWARDING 0x03 // Alternative to 0x00

// ALE entry VLAN/multicast address table entry definitions
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_MASK 0x0000001C
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_SHIFT 2
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_SUPER_MASK 0x00000002
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_SUPER_SHIFT 1
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_MASK 0xC0000000
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_SHIFT 30
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_VLANID_MASK 0x0FFF0000
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_VLANID_SHIFT 16

// ALE entry VLAN/multicast address table entry definitions - Port mask values
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_PORT0 0x01
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_PORT1 0x02
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_PORT2 0x04
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_HOSTPORT ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_PORT0
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_PORTMASK_SLAVEPORT(PORT) (0x01 << PORT)

// ALE entry VLAN/multicast address table entry definitions - Supervisory packet values
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_SUPER_NONSUPERVISORY 0
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_SUPER_SUPERVISORY 1

// ALE entry VLAN/multicast address table entry definitions - Multicast forward state values
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_BLOCKINGFORWARDINGLEARNING 0x01
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_FORWARDINGLEARNING 0x02
#define ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_MCASTFWDSTATE_FORWARDING 0x03 // Alternative to 0x00

// ALE entry unicast address table entry definitions
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_DLRUNICAST_MASK 0x00000020
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_DLRUNICAST_SHIFT 5
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_MASK 0x0000000C
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_SHIFT 2
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_BLOCK_MASK 0x00000002
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_BLOCK_SHIFT 1
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_SECURE_MASK 0x00000001
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_SECURE_SHIFT 0
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_MASK 0xC0000000
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_SHIFT 30

// ALE entry unicast address table entry definitions - DLR unicast values
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_DLRUNICAST_NO 0
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_DLRUNICAST_YES 1

// ALE entry unicast address table entry definitions - Port number values
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT0 0
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT1 1
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT2 2
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_PORTNUMBER_HOSTPORT ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT0

// ALE entry unicast address table entry definitions - Block values
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_BLOCK_NO 0
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_BLOCK_YES 1

// ALE entry unicast address table entry definitions - Secure values
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_SECURE_NO 0
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_SECURE_YES 1

// ALE entry unicast address table entry definitions - Unicast type values
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE 0x00
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_UNICASTTYPE_AGEABLE_NOTTOUCHED 0x01
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE_OUI 0x02
#define ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_UNICASTTYPE_AGEABLE_TOUCHED 0x03

// ALE entry VLAN/unicast address table entry definitions
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_MASK 0x0000000C
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_SHIFT 2
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_BLOCK_MASK 0x00000002
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_BLOCK_SHIFT 1
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_SECURE_MASK 0x00000001
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_SECURE_SHIFT 0
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_MASK 0xC0000000
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_SHIFT 30
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_VLANID_MASK 0x0FFF0000
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_VLANID_SHIFT 16

// ALE entry VLAN/unicast address table entry definitions - Port number values
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT0 0
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT1 1
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT2 2
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_HOSTPORT ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_PORT0

// ALE entry VLAN/unicast address table entry definitions - Block values
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_BLOCK_NO 0
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_BLOCK_YES 1

// ALE entry VLAN/unicast address table entry definitions - Secure values
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_SECURE_NO 0
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_SECURE_YES 1

// ALE entry VLAN/unicast address table entry definitions - Unicast type values
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE 0x00
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_UNICASTTYPE_AGEABLE_NOTTOUCHED 0x01
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE_OUI 0x02
#define ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_UNICASTTYPE_AGEABLE_TOUCHED 0x03

// ALE entry VLAN table entry definitions
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD2_VLANID_MASK 0x0FFF0000
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD2_VLANID_SHIFT 16
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_FORCEUNTAGGEDEGRESS_MASK 0x07000000
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_FORCEUNTAGGEDEGRESS_SHIFT 24
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_REGMCASTFLOODMASK_MASK 0x00070000
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_REGMCASTFLOODMASK_SHIFT 16
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_UNREGMCASTFLOODMASK_MASK 0x00000700
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_UNREGMCASTFLOODMASK_SHIFT 8
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_VLANMEMBERLIST_MASK 0x00000007
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_VLANMEMBERLIST_SHIFT 0

// ALE entry VLAN table entry definitions - Force untagged egress values
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_PORT0 0x01
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_PORT1 0x02
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_PORT2 0x04
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_HOSTPORT ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_PORT0
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_SLAVEPORT(PORT) (0x01 << PORT)

// ALE entry VLAN table entry definitions - VLAN member list values
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_PORT0 0x01
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_PORT1 0x02
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_PORT2 0x04
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_HOSTPORT ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_PORT0
#define ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_SLAVEPORT(PORT) (0x01 << PORT)

// Polling mode flag
static unsigned char ETHERNET_POLLING_MODE;

// CPDMA initialization method
static unsigned char ETHERNET_CPDMA_INITIALIZE(unsigned int INSTANCE) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CURRENT_BUFFERDESCRIPTOR;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *LAST_BUFFERDESCRIPTOR;
	unsigned int BUFFERDESCRIPTOR_COUNTER;
	unsigned int BUFFERPOINTER;

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Initializes TX CPDMA buffer descriptor queue
	{

		// Initializes TX free buffer descriptor queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT = ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_TX_DESCRIPTORCOUNT;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD = (ETHERNET_CPDMA_BUFFERDESCRIPTOR *) (CPSW_INSTANCE->BASEADDRESS_CPPIRAM + ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_TX_OFFSET);
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = null;

		// Initializes TX busy buffer descriptor queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = null;

		// Initializes current buffer descriptor
		CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD;

		// Initializes last buffer descriptor
		LAST_BUFFERDESCRIPTOR = null;

		// Initializes buffer descriptor counter
		BUFFERDESCRIPTOR_COUNTER = ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_TX_DESCRIPTORCOUNT;

		// Initializes TX buffer descriptors
		while (BUFFERDESCRIPTOR_COUNTER > 0) {

			// Allocates buffer
			BUFFERPOINTER = ETHERNET_HOOK_ALLOCATEBUFFER(ETHERNET_BUFFERLENGTH);

			// Verifies buffer pointer
			if (BUFFERPOINTER == null) {
				return false;
			}

			// Sets next buffer descriptor
			CURRENT_BUFFERDESCRIPTOR->NEXT = CURRENT_BUFFERDESCRIPTOR + 1;
			CURRENT_BUFFERDESCRIPTOR->BUFFERPOINTER = BUFFERPOINTER;
			CURRENT_BUFFERDESCRIPTOR->BUFFEROFFSET_BUFFERLENGTH = (ETHERNET_BUFFERLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFERLENGTH_MASK) << ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_BUFFERLENGTH_SHIFT;
			CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = 0;

			// Sets last buffer descriptor
			LAST_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR;

			// Moves to next buffer descriptor
			CURRENT_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR->NEXT;

			// Decreases buffer descriptor counter
			BUFFERDESCRIPTOR_COUNTER--;

			// Verifies buffer descriptor counter
			if (BUFFERDESCRIPTOR_COUNTER % 16 == 0) {

				// Yields
				ETHERNET_HOOK_YIELD();
			}
		}

		// Closes queue
		LAST_BUFFERDESCRIPTOR->NEXT = null;

		// Sets TX buffer descriptor queue tail
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = LAST_BUFFERDESCRIPTOR;
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Initializes RX CPDMA buffer descriptor queue
	{

		// Initializes RX buffer descriptor queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD = (ETHERNET_CPDMA_BUFFERDESCRIPTOR *) (CPSW_INSTANCE->BASEADDRESS_CPPIRAM + ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_RX_OFFSET);
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL = null;

		// Initializes current buffer descriptor
		CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD;

		// Initializes last buffer descriptor
		LAST_BUFFERDESCRIPTOR = null;

		// Initializes buffer descriptor counter
		BUFFERDESCRIPTOR_COUNTER = ETHERNET_CPDMA_BUFFERDESCRIPTOR_MEMORY_RX_DESCRIPTORCOUNT;

		// Initializes RX buffer descriptors
		while (BUFFERDESCRIPTOR_COUNTER > 0) {

			// Allocates buffer
			BUFFERPOINTER = ETHERNET_HOOK_ALLOCATEBUFFER(ETHERNET_BUFFERLENGTH);

			// Verifies buffer pointer
			if (BUFFERPOINTER == null) {
				return false;
			}

			// Sets next buffer descriptor
			CURRENT_BUFFERDESCRIPTOR->NEXT = CURRENT_BUFFERDESCRIPTOR + 1;
			CURRENT_BUFFERDESCRIPTOR->BUFFERPOINTER = BUFFERPOINTER;
			CURRENT_BUFFERDESCRIPTOR->BUFFEROFFSET_BUFFERLENGTH = (ETHERNET_BUFFERLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFERLENGTH_MASK) << ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_BUFFERLENGTH_SHIFT;
			CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK;

			// Sets last buffer descriptor
			LAST_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR;

			// Moves to next buffer descriptor
			CURRENT_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR->NEXT;

			// Decreases buffer descriptor counter
			BUFFERDESCRIPTOR_COUNTER--;

			// Verifies buffer descriptor counter
			if (BUFFERDESCRIPTOR_COUNTER % 16 == 0) {

				// Yields
				ETHERNET_HOOK_YIELD();
			}
		}

		// Closes queue
		LAST_BUFFERDESCRIPTOR->NEXT = null;

		// Sets RX buffer descriptor queue tail
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL = LAST_BUFFERDESCRIPTOR;
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Acknowledges RX and TX interrupts
	CPSWCPDMAEndOfIntVectorWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, CPSW_EOI_TX_PULSE);
	CPSWCPDMAEndOfIntVectorWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, CPSW_EOI_RX_PULSE);

	// Enables transmission and reception
	CPSWCPDMATxEnable(CPSW_INSTANCE->BASEADDRESS_CPDMA);
	CPSWCPDMARxEnable(CPSW_INSTANCE->BASEADDRESS_CPDMA);

	// Enables CPDMA interrupts
	CPSWCPDMATxIntEnable(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL);
	CPSWCPDMARxIntEnable(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL);

	// Success
	return true;
}

// CPDMA sent packets freeing method
static void ETHERNET_CPDMA_FREESENTPACKETS(unsigned int INSTANCE) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CURRENT_BUFFERDESCRIPTOR;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *LAST_BUFFERDESCRIPTOR;

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies TX busy buffer descriptors queue
	if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD == null) {
		return;
	}

	// Initializes current buffer descriptor
	CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD;

	// Initializes last buffer descriptor
	LAST_BUFFERDESCRIPTOR = null;

	// Processes sent buffers
	while (!(CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK)) {

		// Resets buffer descriptor
		CURRENT_BUFFERDESCRIPTOR->BUFFEROFFSET_BUFFERLENGTH = ETHERNET_BUFFERLENGTH;
		CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = 0;

		// Counts freed buffer descriptor
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT++;

		// Sets last buffer descriptor
		LAST_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR;

		// Moves to next buffer descriptor
		CURRENT_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR->NEXT;

		// Verifies end of queue
		if (CURRENT_BUFFERDESCRIPTOR == null) {
			break;
		}
	}

	// Verifies if there are released buffers
	if (LAST_BUFFERDESCRIPTOR != null) {

		// Verifies TX free buffer descriptors queue
		if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD == null) {

			// Inserts sent buffer descriptors in empty free queue
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD;
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = LAST_BUFFERDESCRIPTOR;
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL->NEXT = null;

			// Removes sent buffer descriptors from busy queue
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD = CURRENT_BUFFERDESCRIPTOR;
			if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD == null) {
				CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = null;
			}
		} else {

			// Inserts sent buffer descriptors in non-empty free queue
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL->NEXT = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD;
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = LAST_BUFFERDESCRIPTOR;
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL->NEXT = null;

			// Removes sent buffer descriptors from busy queue
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD = CURRENT_BUFFERDESCRIPTOR;
			if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD == null) {
				CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = null;
			}
		}
	}
}

// CPDMA TX interrupt handler
static void ETHERNET_CPSW_TXINTERRUPTHANDLER(unsigned int INSTANCE) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Frees sent packets
	ETHERNET_CPDMA_FREESENTPACKETS(INSTANCE);

	// Acknowledges transmission
	CPSWCPDMATxCPWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL, (unsigned int) CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL);

	// Acknowledges interrupt
	CPSWCPDMAEndOfIntVectorWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, CPSW_EOI_TX_PULSE);
}

// CPSW core 0 TX ISR
static void ETHERNET_CPSW_CORE0TXISR(void) {

	// Handles interrupt for default instance
	ETHERNET_CPSW_TXINTERRUPTHANDLER(ETHERNET_DEFAULTINSTANCE);
}

// CPDMA RX interrupt handler
static void ETHERNET_CPSW_RXINTERRUPTHANDLER(unsigned int INSTANCE) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CURRENT_BUFFERDESCRIPTOR;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *LAST_BUFFERDESCRIPTOR;
	unsigned int PORT;
	unsigned int PACKET_LENGTH;

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Initializes current buffer descriptor
	CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD;

	// Initializes last buffer descriptor
	LAST_BUFFERDESCRIPTOR = null;

	// Processes received buffers
	while ((CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK) != ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK) {

		// Gets origin port
		PORT = (CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_MASK) >> ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_SHIFT;

		// Gets packet length
		PACKET_LENGTH = CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_PACKETLENGTH_MASK;

		// Verifies passed CRC flag
		if (CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_PASSEDCRC_MASK) {
			PACKET_LENGTH -= 4;
		}

		// If packet is not entirely contained in this buffer (if not, it's dropped)
		if ((CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & (ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SOP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOP_MASK)) == (ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SOP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOP_MASK)) {

			// Processes the packet
			ETHERNET_HOOK_RECEIVEPACKET(INSTANCE, PORT, (unsigned char *) CURRENT_BUFFERDESCRIPTOR->BUFFERPOINTER, PACKET_LENGTH);
		}

		// Resets buffer descriptor
		CURRENT_BUFFERDESCRIPTOR->BUFFEROFFSET_BUFFERLENGTH = ETHERNET_BUFFERLENGTH;
		CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK;

		// Acknowledges processed buffer
		CPSWCPDMARxCPWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL, (unsigned int) CURRENT_BUFFERDESCRIPTOR);

		// Sets last buffer descriptor
		LAST_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR;

		// Moves to next buffer descriptor
		CURRENT_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR->NEXT;

		// Verifies end of queue
		if (CURRENT_BUFFERDESCRIPTOR == null) {
			break;
		}
	}

	// Verifies end of queue
	if (CURRENT_BUFFERDESCRIPTOR != null) {

		// Reinserts received buffers at the end of the queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL->NEXT = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD;
		LAST_BUFFERDESCRIPTOR->NEXT = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD = CURRENT_BUFFERDESCRIPTOR;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL = LAST_BUFFERDESCRIPTOR;
	} else {

		// Sets CPDMA RX head buffer descriptor
		CPSWCPDMARxHdrDescPtrWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, (unsigned int) (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD), ETHERNET_CPDMA_DEFAULTCHANNEL);
	}

	// Acknowledges interrupt
	CPSWCPDMAEndOfIntVectorWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, CPSW_EOI_RX_PULSE);
}

// CPSW core 0 RX ISR
static void ETHERNET_CPSW_CORE0RXISR(void) {

	// Handles interrupt for default instance
	ETHERNET_CPSW_RXINTERRUPTHANDLER(ETHERNET_DEFAULTINSTANCE);
}

// ALE find free entry method
unsigned char ETHERNET_ALE_FINDFREEENTRY(unsigned int BASEADDRESS_ALE, unsigned int *INDEX) {
	unsigned int i;
	ETHERNET_ALE_ENTRY ALE_ENTRY;

	// Iterates ALE entries
	for (i = 0; i < ETHERNET_ALE_MAXIMUMENTRIES; i++) {

		// Gets ALE entry
		CPSWALETableEntryGet(BASEADDRESS_ALE, i, (unsigned int *) &ALE_ENTRY);

		// Verifies free entry
		if ((ALE_ENTRY.WORD2 & ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_MASK) >> ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT == ETHERNET_ALE_ENTRY_ENTRYTYPE_FREEENTRY) {
			*INDEX = i;
			return true;
		}
	}

	// Failure
	return false;
}

// ALE make free table entry method
void ETHERNET_ALE_MAKEFREETABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_FREEENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);
}

// ALE make multicast address table entry method
void ETHERNET_ALE_MAKEMULTICASTADDRESSTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned char PORT_MASK, unsigned char SUPER, unsigned char MCAST_FWD_STATE, unsigned char *MULTICAST_ADDRESS) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets port mask
	ALE_ENTRY->WORD3 |= (PORT_MASK << ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_SHIFT) & ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_MASK;

	// Sets supervisory packet
	ALE_ENTRY->WORD3 |= (SUPER << ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_SUPER_SHIFT) & ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD3_SUPER_MASK;

	// Sets multicast forward state
	ALE_ENTRY->WORD2 |= (MCAST_FWD_STATE << ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_SHIFT) & ETHERNET_ALE_ENTRY_MULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_MASK;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_ADDRESSENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets multicast address
	ALE_ENTRY->WORD2 |= (MULTICAST_ADDRESS[1] << 0) | (MULTICAST_ADDRESS[0] << 8);
	ALE_ENTRY->WORD1 |= (MULTICAST_ADDRESS[5] << 0) | (MULTICAST_ADDRESS[4] << 8) | (MULTICAST_ADDRESS[3] << 16) | (MULTICAST_ADDRESS[2] << 24);
}

// ALE make VLAN/multicast address table entry method
void ETHERNET_ALE_MAKEVLANMULTICASTADDRESSTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned char PORT_MASK, unsigned char SUPER, unsigned char MCAST_FWD_STATE, unsigned int VLAN_ID, unsigned char *MULTICAST_ADDRESS) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets port mask
	ALE_ENTRY->WORD3 |= (PORT_MASK << ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_SHIFT) & ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_PORTMASK_MASK;

	// Sets supervisory packet
	ALE_ENTRY->WORD3 |= (SUPER << ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_SUPER_SHIFT) & ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD3_SUPER_MASK;

	// Sets multicast forward state
	ALE_ENTRY->WORD2 |= (MCAST_FWD_STATE << ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_SHIFT) & ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_MCASTFWDSTATE_MASK;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_VLANADDRESSENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets VLAN ID
	ALE_ENTRY->WORD2 |= (VLAN_ID << ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_VLANID_SHIFT) & ETHERNET_ALE_ENTRY_VLANMULTICASTADDRESSTABLEENTRY_WORD2_VLANID_MASK;

	// Sets multicast address
	ALE_ENTRY->WORD2 |= (MULTICAST_ADDRESS[1] << 0) | (MULTICAST_ADDRESS[0] << 8);
	ALE_ENTRY->WORD1 |= (MULTICAST_ADDRESS[5] << 0) | (MULTICAST_ADDRESS[4] << 8) | (MULTICAST_ADDRESS[3] << 16) | (MULTICAST_ADDRESS[2] << 24);
}

// ALE make unicast address table entry method
void ETHERNET_ALE_MAKEUNICASTADDRESSTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned char DLR_UNICAST, unsigned char PORT_NUMBER, unsigned char BLOCK, unsigned char SECURE, unsigned char UNICAST_TYPE, unsigned char *UNICAST_ADDRESS) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets DLR unicast
	ALE_ENTRY->WORD3 |= (DLR_UNICAST << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_DLRUNICAST_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_DLRUNICAST_MASK;

	// Sets port number
	ALE_ENTRY->WORD3 |= (PORT_NUMBER << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_MASK;

	// Sets block
	ALE_ENTRY->WORD3 |= (BLOCK << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_BLOCK_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_BLOCK_MASK;

	// Sets secure
	ALE_ENTRY->WORD3 |= (SECURE << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_SECURE_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD3_SECURE_MASK;

	// Sets unicast type
	ALE_ENTRY->WORD2 |= (UNICAST_TYPE << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_MASK;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_ADDRESSENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets unicast address
	ALE_ENTRY->WORD2 |= (UNICAST_ADDRESS[1] << 0) | (UNICAST_ADDRESS[0] << 8);
	ALE_ENTRY->WORD1 |= (UNICAST_ADDRESS[5] << 0) | (UNICAST_ADDRESS[4] << 8) | (UNICAST_ADDRESS[3] << 16) | (UNICAST_ADDRESS[2] << 24);
}

// ALE make OUI unicast address table entry method
void ETHERNET_ALE_MAKEOUIUNICASTADDRESSTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned char *UNICAST_OUI) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets unicast type
	ALE_ENTRY->WORD2 = ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE_OUI;
	ALE_ENTRY->WORD2 = (ALE_ENTRY->WORD2 << ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_SHIFT) & ETHERNET_ALE_ENTRY_UNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_MASK;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_ADDRESSENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets packet address
	ALE_ENTRY->WORD2 |= (UNICAST_OUI[1] << 0) | (UNICAST_OUI[0] << 8);
	ALE_ENTRY->WORD1 |= (UNICAST_OUI[2] << 24);
}

// ALE make VLAN/unicast address table entry method
void ETHERNET_ALE_MAKEVLANUNICASTADDRESSTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned char PORT_NUMBER, unsigned char BLOCK, unsigned char SECURE, unsigned char UNICAST_TYPE, unsigned int VLAN_ID, unsigned char *UNICAST_ADDRESS) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets port number
	ALE_ENTRY->WORD3 |= (PORT_NUMBER << ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_SHIFT) & ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_PORTNUMBER_MASK;

	// Sets block
	ALE_ENTRY->WORD3 |= (BLOCK << ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_BLOCK_SHIFT) & ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_BLOCK_MASK;

	// Sets secure
	ALE_ENTRY->WORD3 |= (SECURE << ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_SECURE_SHIFT) & ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD3_SECURE_MASK;

	// Sets unicast type
	ALE_ENTRY->WORD2 |= (UNICAST_TYPE << ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_SHIFT) & ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_UNICASTTYPE_MASK;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_VLANADDRESSENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets VLAN ID
	ALE_ENTRY->WORD2 |= (VLAN_ID << ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_VLANID_SHIFT) & ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_WORD2_VLANID_MASK;

	// Sets unicast address
	ALE_ENTRY->WORD2 |= (UNICAST_ADDRESS[1] << 0) | (UNICAST_ADDRESS[0] << 8);
	ALE_ENTRY->WORD1 |= (UNICAST_ADDRESS[5] << 0) | (UNICAST_ADDRESS[4] << 8) | (UNICAST_ADDRESS[3] << 16) | (UNICAST_ADDRESS[2] << 24);
}

// ALE make VLAN table entry method
void ETHERNET_ALE_MAKEVLANTABLEENTRY(ETHERNET_ALE_ENTRY *ALE_ENTRY, unsigned int VLAN_ID, unsigned char FORCE_UNTAGGED_EGRESS, unsigned char REG_MCAST_FLOOD_MASK, unsigned char UNREG_MCAST_FLOOD_MASK, unsigned char VLAN_MEMBER_LIST) {

	// Clears entry
	ALE_ENTRY->WORD1 = 0;
	ALE_ENTRY->WORD2 = 0;
	ALE_ENTRY->WORD3 = 0;

	// Sets entry type
	ALE_ENTRY->WORD2 |= (ETHERNET_ALE_ENTRY_ENTRYTYPE_VLANENTRY << ETHERNET_ALE_ENTRY_WORD2_ENTRYTYPE_SHIFT);

	// Sets VLAN ID
	ALE_ENTRY->WORD2 |= (VLAN_ID << ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD2_VLANID_SHIFT) & ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD2_VLANID_MASK;

	// Sets force untagged packet egress
	ALE_ENTRY->WORD1 |= (FORCE_UNTAGGED_EGRESS << ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_FORCEUNTAGGEDEGRESS_SHIFT) & ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_FORCEUNTAGGEDEGRESS_MASK;

	// Sets registered multicast flood mask
	ALE_ENTRY->WORD1 |= (REG_MCAST_FLOOD_MASK << ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_REGMCASTFLOODMASK_SHIFT) & ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_REGMCASTFLOODMASK_MASK;

	// Sets unregistered multicast flood mask
	ALE_ENTRY->WORD1 |= (UNREG_MCAST_FLOOD_MASK << ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_UNREGMCASTFLOODMASK_SHIFT) & ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_UNREGMCASTFLOODMASK_MASK;

	// Sets VLAN member list
	ALE_ENTRY->WORD1 |= (VLAN_MEMBER_LIST << ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_VLANMEMBERLIST_SHIFT) & ETHERNET_ALE_ENTRY_VLANTABLEENTRY_WORD1_VLANMEMBERLIST_MASK;
}

// ALE set table entry method
unsigned char ETHERNET_ALE_SETTABLEENTRY(unsigned int BASEADDRESS_ALE, unsigned int INDEX, ETHERNET_ALE_ENTRY *ALE_ENTRY) {

	// Verifies index
	if (INDEX >= ETHERNET_ALE_MAXIMUMENTRIES) {
		return false;
	}

	// Sets ALE table entry
	CPSWALETableEntrySet(BASEADDRESS_ALE, INDEX, (unsigned int *) ALE_ENTRY);

	// Success
	return true;
}

// Startup method
unsigned char ETHERNET_STARTUP(unsigned char POLLING_MODE) {
	unsigned int INSTANCE;

	// Iterates instances
	for (INSTANCE = 0; INSTANCE < ETHERNET_MAXIMUM_INSTANCES; INSTANCE++) {
		ETHERNET_CPSW_INSTANCES[INSTANCE].INITIALIZED = false;
	}

	// Sets polling mode flag
	ETHERNET_POLLING_MODE = POLLING_MODE;

	// Sets CPSW pin mux
	CPSWPinMuxSetup();

	// Enables CPSW clock
	CPSWClkEnable();

	// Selects chip configuration RGMII
	EVMPortMIIModeSelect();

	// Yields
	ETHERNET_HOOK_YIELD();

	// Verifies polling mode
	if (!POLLING_MODE) {

		// Registers CPSW interrupts
		IntRegister(SYS_INT_3PGSWTXINT0, ETHERNET_CPSW_CORE0TXISR);
		IntRegister(SYS_INT_3PGSWRXINT0, ETHERNET_CPSW_CORE0RXISR);

		// Sets CPSW interrupts priorities
		IntPrioritySet(SYS_INT_3PGSWTXINT0, 0, AINTC_HOSTINT_ROUTE_IRQ);
		IntPrioritySet(SYS_INT_3PGSWRXINT0, 0, AINTC_HOSTINT_ROUTE_IRQ);

		// Enables CPSW interrupts
		IntSystemEnable(SYS_INT_3PGSWTXINT0);
		IntSystemEnable(SYS_INT_3PGSWRXINT0);
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Calls initialization hook
	if (!ETHERNET_HOOK_INITIALIZE()) {
		return false;
	}

	// Success
	return true;
}

// Instance initialization method
unsigned char ETHERNET_INITIALIZE_INSTANCE(unsigned int INSTANCE) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	ETHERNET_CPSW_PORT *CPSW_PORT;
	unsigned int PORT;

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Verifies instance
	switch (INSTANCE) {
	case 0:
		// Initializes
		CPSW_INSTANCE->BASEADDRESS_SS = SOC_CPSW_SS_REGS;
		CPSW_INSTANCE->BASEADDRESS_MDIO = SOC_CPSW_MDIO_REGS;
		CPSW_INSTANCE->BASEADDRESS_WR = SOC_CPSW_WR_REGS;
		CPSW_INSTANCE->BASEADDRESS_CPDMA = SOC_CPSW_CPDMA_REGS;
		CPSW_INSTANCE->BASEADDRESS_ALE = SOC_CPSW_ALE_REGS;
		CPSW_INSTANCE->BASEADDRESS_STAT = SOC_CPSW_STAT_REGS;
		CPSW_INSTANCE->BASEADDRESS_HOSTPORT = SOC_CPSW_PORT_0_REGS;
		CPSW_INSTANCE->BASEADDRESS_CPPIRAM = SOC_CPSW_CPPI_RAM_REGS;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD = null;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL = null;

		// Iterates ports
		for (PORT = 1; PORT <= ETHERNET_MAXIMUM_INSTANCE_PORTS; PORT++) {

			// Gets port
			CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

			// Initializes port
			CPSW_PORT->INITIALIZED = false;
			CPSW_PORT->BASEADDRESS_PORT = null;
			CPSW_PORT->BASEADDRESS_SLIVER = null;
			CPSW_PORT->PHY_ADDRESS = null;
			CPSW_PORT->PHY_GIGABIT = null;
			CPSW_PORT->ALE_ENTRY_INDEX_VLANTABLE = 0xFFFFFFFF;
			CPSW_PORT->ALE_ENTRY_INDEX_VLANUNICASTADDRESSTABLE = 0xFFFFFFFF;

			// Verifies port
			switch (PORT) {
			case 1:
				// Initializes
				CPSW_PORT->BASEADDRESS_PORT = SOC_CPSW_PORT_1_REGS;
				CPSW_PORT->BASEADDRESS_SLIVER = SOC_CPSW_SLIVER_1_REGS;
				CPSW_PORT->PHY_ADDRESS = 0;
				break;
			case 2:
				// Initializes
				CPSW_PORT->BASEADDRESS_PORT = SOC_CPSW_PORT_2_REGS;
				CPSW_PORT->BASEADDRESS_SLIVER = SOC_CPSW_SLIVER_2_REGS;
				CPSW_PORT->PHY_ADDRESS = 1;
				break;
			default:
				return false;
			}
		}
		break;
	default:
		return false;
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Resets SS
	CPSWSSReset(CPSW_INSTANCE->BASEADDRESS_SS);

	// Resets WR
	CPSWWrReset(CPSW_INSTANCE->BASEADDRESS_WR);

	// Iterates ports
	for (PORT = 1; PORT <= ETHERNET_MAXIMUM_INSTANCE_PORTS; PORT++) {

		// Gets port
		CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

		// Resets port
		CPSWSlReset(CPSW_PORT->BASEADDRESS_SLIVER);

	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Resets CPDMA
	CPSWCPDMAReset(CPSW_INSTANCE->BASEADDRESS_CPDMA);

	// Initializes MDIO
	MDIOInit(CPSW_INSTANCE->BASEADDRESS_MDIO, ETHERNET_MDIO_INPUT_FREQUENCY, ETHERNET_MDIO_OUTPUT_FREQUENCY);

	// Delays for 1ms
	ETHERNET_HOOK_DELAY(1);

	// Initializes ALE
	CPSWALEInit(CPSW_INSTANCE->BASEADDRESS_ALE);

	// Yields
	ETHERNET_HOOK_YIELD();

	// Sets port 0 state to FORWARD
	CPSWALEPortStateSet(CPSW_INSTANCE->BASEADDRESS_ALE, 0, CPSW_ALE_PORT_STATE_FWD);

	// For dual MAC mode, configures VLAN aware mode
	CPSWALEVLANAwareSet(CPSW_INSTANCE->BASEADDRESS_ALE);

	// Enables dual MAC mode
	CPSWHostPortDualMacModeSet(CPSW_INSTANCE->BASEADDRESS_HOSTPORT);

	// Yields
	ETHERNET_HOOK_YIELD();

	// Enables statistics
	CPSWStatisticsEnable(CPSW_INSTANCE->BASEADDRESS_SS);

	// Initializes instance CPDMA
	if (!ETHERNET_CPDMA_INITIALIZE(INSTANCE)) {
		return false;
	}

	// Sets CPDMA RX head buffer descriptor
	CPSWCPDMARxHdrDescPtrWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, (unsigned int) CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD, ETHERNET_CPDMA_DEFAULTCHANNEL);

	// Yields
	ETHERNET_HOOK_YIELD();

	// Verifies polling mode
	if (!ETHERNET_POLLING_MODE) {

		// Enables WR interrupts
		CPSWWrCoreIntEnable(CPSW_INSTANCE->BASEADDRESS_WR, ETHERNET_CPSW_DEFAULTCORE, ETHERNET_CPDMA_DEFAULTCHANNEL, CPSW_CORE_INT_TX_PULSE);
		CPSWWrCoreIntEnable(CPSW_INSTANCE->BASEADDRESS_WR, ETHERNET_CPSW_DEFAULTCORE, ETHERNET_CPDMA_DEFAULTCHANNEL, CPSW_CORE_INT_RX_PULSE);
	}

	// Sets initialized flag
	CPSW_INSTANCE->INITIALIZED = true;

	// Success
	return true;
}

// Initialize instance port method
unsigned char ETHERNET_INITIALIZE_INSTANCE_PORT(unsigned int INSTANCE, unsigned int PORT, unsigned char PHY_GIGABIT, unsigned char *MAC_ADDRESS) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	ETHERNET_CPSW_PORT *CPSW_PORT;
	ETHERNET_ALE_ENTRY ALE_ENTRY_VLANTABLE;
	ETHERNET_ALE_ENTRY ALE_ENTRY_VLANUNICASTADDRESSTABLE;

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (!CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Verifies port
	if ((PORT - 1) >= ETHERNET_MAXIMUM_INSTANCE_PORTS) {
		return false;
	}

	// Verifies instance
	switch (INSTANCE) {
	case 0:

		// Gets port
		CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

		// Verifies port initialization
		if (CPSW_PORT->INITIALIZED) {
			return false;
		}

		// Verifies port
		switch (PORT) {
		case 1:
			// Initializes
			CPSW_PORT->PHY_GIGABIT = PHY_GIGABIT;
			break;
		case 2:
			// Initializes
			CPSW_PORT->PHY_GIGABIT = PHY_GIGABIT;
			break;
		default:
			return false;
		}

		// Sets initialized flag
		CPSW_PORT->INITIALIZED = true;
		break;
	default:
		return false;
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Resets port
	CPSWSlReset(CPSW_PORT->BASEADDRESS_SLIVER);

	// Sets port source address
	CPSWPortSrcAddrSet(CPSW_PORT->BASEADDRESS_PORT, MAC_ADDRESS);

	// Sets port index as VLAN identifier
	CPSWPortVLANConfig(CPSW_PORT->BASEADDRESS_PORT, PORT, 0, 0);

	// Creates port to host VLAN in ALE
	{

		// Verifies VLAN table entry index
		if (CPSW_PORT->ALE_ENTRY_INDEX_VLANTABLE == 0xFFFFFFFF) {

			// Finds ALE free entry
			if (!ETHERNET_ALE_FINDFREEENTRY(CPSW_INSTANCE->BASEADDRESS_ALE, &CPSW_PORT->ALE_ENTRY_INDEX_VLANTABLE)) {
				return false;
			}
		}

		// Makes VLAN table entry - Uses port number as VLAN ID
		ETHERNET_ALE_MAKEVLANTABLEENTRY(&ALE_ENTRY_VLANTABLE, PORT, ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_HOSTPORT | ETHERNET_ALE_ENTRY_VLANTABLEENTRY_FORCEUNTAGGEDEGRESS_SLAVEPORT(PORT), 0, 0, ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_HOSTPORT | ETHERNET_ALE_ENTRY_VLANTABLEENTRY_VLANMEMBERLIST_SLAVEPORT(PORT));

		// Sets table entry
		if (!ETHERNET_ALE_SETTABLEENTRY(CPSW_INSTANCE->BASEADDRESS_ALE, CPSW_PORT->ALE_ENTRY_INDEX_VLANTABLE, &ALE_ENTRY_VLANTABLE)) {
			return false;
		}

		// Verifies VLAN/unicast address table entry index
		if (CPSW_PORT->ALE_ENTRY_INDEX_VLANUNICASTADDRESSTABLE == 0xFFFFFFFF) {

			// Finds ALE free entry
			if (!ETHERNET_ALE_FINDFREEENTRY(CPSW_INSTANCE->BASEADDRESS_ALE, &CPSW_PORT->ALE_ENTRY_INDEX_VLANUNICASTADDRESSTABLE)) {
				return false;
			}
		}

		// Makes VLAN/unicast address table entry
		ETHERNET_ALE_MAKEVLANUNICASTADDRESSTABLEENTRY(&ALE_ENTRY_VLANUNICASTADDRESSTABLE, ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_PORTNUMBER_HOSTPORT, ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_BLOCK_NO, ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_SECURE_NO, ETHERNET_ALE_ENTRY_VLANUNICASTADDRESSTABLEENTRY_UNICASTTYPE_NOTAGEABLE, PORT, MAC_ADDRESS);

		// Sets table entry
		if (!ETHERNET_ALE_SETTABLEENTRY(CPSW_INSTANCE->BASEADDRESS_ALE, CPSW_PORT->ALE_ENTRY_INDEX_VLANUNICASTADDRESSTABLE, &ALE_ENTRY_VLANUNICASTADDRESSTABLE)) {
			return false;
		}
	}

	// Yields
	ETHERNET_HOOK_YIELD();

	// Sets port state to FORWARD
	CPSWALEPortStateSet(CPSW_INSTANCE->BASEADDRESS_ALE, PORT, CPSW_ALE_PORT_STATE_FWD);

	// Checks if ethernet PHY is present
	if ((MDIOPhyAliveStatusGet(CPSW_INSTANCE->BASEADDRESS_MDIO) & (1 << CPSW_PORT->PHY_ADDRESS)) == 0) {
		return false;
	}

	// Success
	return true;
}

// Auto-negotiate instance port method
unsigned char ETHERNET_AUTONEGOTIATE_INSTANCE_PORT(unsigned int INSTANCE, unsigned int PORT, unsigned int TIME_OUT) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	ETHERNET_CPSW_PORT *CPSW_PORT;
	unsigned short ADVERTISEMENT;
	unsigned short PARTNER_ABILITIES;
	unsigned short GIGABIT_ADVERTISEMENT;
	unsigned short GIGABIT_PARTNER_ABILITIES;
	unsigned int TRANSFER_MODE;
	unsigned int COUNTER;

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (!CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Verifies port
	if ((PORT - 1) >= ETHERNET_MAXIMUM_INSTANCE_PORTS) {
		return false;
	}

	// Gets port
	CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

	// Verifies port initialization
	if (!CPSW_PORT->INITIALIZED) {
		return false;
	}

	// Advertise 10/100 Mbps half and full duplex
	ADVERTISEMENT = (PHY_10BT | PHY_10BT_FD | PHY_100BTX | PHY_100BTX_FD);

	// If PHY is gigabit capable, advertise
	GIGABIT_PARTNER_ABILITIES = (CPSW_PORT->PHY_GIGABIT ? true : false);
	GIGABIT_ADVERTISEMENT = (GIGABIT_PARTNER_ABILITIES ? PHY_1000BT_FD : 0);

	// Starts auto-negotiation
	if (PhyAutoNegotiate(CPSW_INSTANCE->BASEADDRESS_MDIO, CPSW_PORT->PHY_ADDRESS, &ADVERTISEMENT, &GIGABIT_ADVERTISEMENT) != true) {
		return false;
	}

	// Calculates counter
	COUNTER = (TIME_OUT >= 10 ? TIME_OUT / 10 : 0);

	// Runs auto-negotiation
	while (true) {

		// Delays
		ETHERNET_HOOK_DELAY(10);

		// Verifies auto-negotiation status
		if (PhyAutoNegStatusGet(CPSW_INSTANCE->BASEADDRESS_MDIO, CPSW_PORT->PHY_ADDRESS) == true) {
			break;
		}

		// Verifies counter
		if (COUNTER > 0) {

			// Decreases counter
			COUNTER--;

			// If counter reaches zero the process failed
			if (COUNTER == 0) {
				return false;
			}
		}

		// Yields
		ETHERNET_HOOK_YIELD();
	}

	// Gets partner abilities
	if (PhyPartnerAbilityGet(CPSW_INSTANCE->BASEADDRESS_MDIO, CPSW_PORT->PHY_ADDRESS, &PARTNER_ABILITIES, &GIGABIT_PARTNER_ABILITIES) != true) {
		return false;
	}

	// Defines transfer mode based on partner abilities
	if (GIGABIT_PARTNER_ABILITIES & PHY_LINK_PARTNER_1000BT_FD) {
		TRANSFER_MODE = CPSW_SLIVER_GIG_FULL_DUPLEX;
	} else {
		if ((ADVERTISEMENT & PARTNER_ABILITIES) & PHY_100BTX_FD) {
			TRANSFER_MODE = CPSW_SLIVER_NON_GIG_FULL_DUPLEX;
		} else if ((ADVERTISEMENT & PARTNER_ABILITIES) & PHY_100BTX) {
			TRANSFER_MODE = CPSW_SLIVER_NON_GIG_HALF_DUPLEX;
		} else if ((ADVERTISEMENT & PARTNER_ABILITIES) & PHY_10BT_FD) {
			TRANSFER_MODE = CPSW_SLIVER_INBAND | CPSW_SLIVER_NON_GIG_FULL_DUPLEX;
		} else if ((ADVERTISEMENT & PARTNER_ABILITIES) & PHY_10BT) {
			TRANSFER_MODE = CPSW_SLIVER_INBAND | CPSW_SLIVER_NON_GIG_HALF_DUPLEX;
		} else {
			return false;
		}
	}

	// Sets transfer mode according to auto-negotiation
	CPSWSlTransferModeSet(CPSW_PORT->BASEADDRESS_SLIVER, TRANSFER_MODE);

	// Yields
	ETHERNET_HOOK_YIELD();

	// Calculates counter
	COUNTER = (TIME_OUT >= 10 ? TIME_OUT / 10 : 0);

	// Runs link status verification
	while (true) {

		// Delays
		ETHERNET_HOOK_DELAY(10);

		// Checks if PHY link exists
		if (PhyLinkStatusGet(CPSW_INSTANCE->BASEADDRESS_MDIO, CPSW_PORT->PHY_ADDRESS, 1) == true) {
			break;
		}

		// Verifies counter
		if (COUNTER > 0) {

			// Decreases counter
			COUNTER--;

			// If counter reaches zero the process failed
			if (COUNTER == 0) {
				return false;
			}
		}

		// Yields
		ETHERNET_HOOK_YIELD();
	}

	// Enables RGMII for port
	CPSWSlRGMIIEnable(CPSW_PORT->BASEADDRESS_SLIVER);

	// Success
	return true;
}

// Link up instance port verification method
unsigned char ETHERNET_INSTANCE_PORT_ISLINKUP(unsigned int INSTANCE, unsigned int PORT, unsigned int TIME_OUT) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	ETHERNET_CPSW_PORT *CPSW_PORT;
	unsigned int COUNTER;

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (!CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Verifies port
	if ((PORT - 1) >= ETHERNET_MAXIMUM_INSTANCE_PORTS) {
		return false;
	}

	// Gets port
	CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

	// Verifies port initialization
	if (!CPSW_PORT->INITIALIZED) {
		return false;
	}

	// Calculates counter
	COUNTER = (TIME_OUT >= 10 ? TIME_OUT / 10 : 0);

	// Runs link status verification
	while (true) {

		// Delays
		ETHERNET_HOOK_DELAY(10);

		// Checks if PHY link exists
		if (PhyLinkStatusGet(CPSW_INSTANCE->BASEADDRESS_MDIO, CPSW_PORT->PHY_ADDRESS, 1) == true) {
			break;
		}

		// Verifies counter
		if (COUNTER > 0) {

			// Decreases counter
			COUNTER--;

			// If counter reaches zero the process failed
			if (COUNTER == 0) {
				return false;
			}
		}

		// Yields
		ETHERNET_HOOK_YIELD();
	}

	// Success
	return true;
}

// Packet receiving method
unsigned int ETHERNET_RECEIVEPACKET(unsigned int INSTANCE, unsigned int *PORT, unsigned char *PACKET, unsigned int LENGTH, unsigned int TIME_OUT, unsigned char ENTER_CRITICAL_SECTION) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CURRENT_BUFFERDESCRIPTOR;
	unsigned char *PACKET_BUFFER;
	unsigned int PACKET_LENGTH;
	unsigned int INDEX;
	unsigned int COUNTER;

	// Verifies polling mode
	if (!ETHERNET_POLLING_MODE) {
		return false;
	}

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (!CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Calculates counter
	COUNTER = (TIME_OUT >= 10 ? TIME_OUT / 10 : 0);

	// Runs link status verification
	while (true) {

		// Delays
		ETHERNET_HOOK_DELAY(10);

		// Verifies RX interrupt status
		if (CPSWCPDMARxIntStatRawGet(CPSW_INSTANCE->BASEADDRESS_CPDMA, CPSW_CPDMA_RX_INTSTAT_RAW_RX0_PEND, CPDMA_RX_INT_PULSE_PEND)) {
			break;
		}

		// Verifies counter
		if (COUNTER > 0) {

			// Decreases counter
			COUNTER--;

			// If counter reaches zero the process failed
			if (COUNTER == 0) {
				return false;
			}
		}

		// Yields
		ETHERNET_HOOK_YIELD();
	}

	// Verifies enter critical section flag
	if (ENTER_CRITICAL_SECTION) {

		// Enters critical section
		ETHERNET_HOOK_ENTERCRITICALSECTION();
	}

	// Initializes current buffer descriptor
	CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD;

	// Verifies received buffer ownership
	if ((CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK) == ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK) {

		// Verifies enter critical section flag
		if (ENTER_CRITICAL_SECTION) {

			// Exits critical section
			ETHERNET_HOOK_EXITCRITICALSECTION();
		}
		return false;
	}

	// Gets origin port
	*PORT = (CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_MASK) >> ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_FROMPORT_SHIFT;

	// Gets packet length
	PACKET_LENGTH = CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_PACKETLENGTH_MASK;

	// Verifies passed CRC flag
	if (CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_PASSEDCRC_MASK) {
		PACKET_LENGTH -= 4;
	}

	// Verifies packet length
	if (PACKET_LENGTH <= LENGTH) {

		// If packet is entirely contained in this buffer
		if ((CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & (ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SOP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOP_MASK)) == (ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_SOP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_EOP_MASK)) {

			// Prepares packet buffer
			PACKET_BUFFER = (unsigned char *) CURRENT_BUFFERDESCRIPTOR->BUFFERPOINTER;

			// Copies packet
			for (INDEX = 0; INDEX < PACKET_LENGTH; INDEX++) {
				PACKET[INDEX] = PACKET_BUFFER[INDEX];
			}
		} else {

			// Sets packet length to zero (drops packet)
			PACKET_LENGTH = 0;
		}
	} else {

		// Sets packet length to zero (drops packet)
		PACKET_LENGTH = 0;
	}

	// Resets buffer descriptor
	CURRENT_BUFFERDESCRIPTOR->BUFFEROFFSET_BUFFERLENGTH = ETHERNET_BUFFERLENGTH;
	CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = ETHERNET_CPDMA_BUFFERDESCRIPTOR_RX_FLAGS_OWNERSHIP_MASK;

	// Acknowledges processed buffer
	CPSWCPDMARxCPWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL, (unsigned int) CURRENT_BUFFERDESCRIPTOR);

	// Reinserts received buffer at the end of the queue
	CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL->NEXT = CURRENT_BUFFERDESCRIPTOR;
	CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL = CURRENT_BUFFERDESCRIPTOR;
	CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_HEAD = CURRENT_BUFFERDESCRIPTOR->NEXT;
	CURRENT_BUFFERDESCRIPTOR->NEXT = null;

	// Verifies CPDMA RX head buffer descriptor
	if (CPSWCPDMARxHdrDescPtrRead(CPSW_INSTANCE->BASEADDRESS_CPDMA, ETHERNET_CPDMA_DEFAULTCHANNEL) == null) {

		// Sets CPDMA RX head buffer descriptor
		CPSWCPDMARxHdrDescPtrWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, (unsigned int) (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_RX_TAIL), ETHERNET_CPDMA_DEFAULTCHANNEL);
	}

	// Verifies enter critical section flag
	if (ENTER_CRITICAL_SECTION) {

		// Exits critical section
		ETHERNET_HOOK_EXITCRITICALSECTION();
	}

	// Success
	return PACKET_LENGTH;
}

// Packet sending method
unsigned char ETHERNET_SENDPACKET(unsigned int INSTANCE, unsigned int PORT, unsigned char *PACKET, unsigned int LENGTH, unsigned char ENTER_CRITICAL_SECTION) {
	ETHERNET_CPSW_INSTANCE *CPSW_INSTANCE;
	ETHERNET_CPSW_PORT *CPSW_PORT;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *CURRENT_BUFFERDESCRIPTOR;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *LAST_BUFFERDESCRIPTOR;
	volatile ETHERNET_CPDMA_BUFFERDESCRIPTOR *LAST_ENQUEUED_BUFFERDESCRIPTOR;
	unsigned char *BUFFER_PACKET;
	unsigned int BUFFER_PACKET_LENGTH;
	unsigned int BUFFER_PACKET_INDEX;

	// Verifies instance
	if (INSTANCE >= ETHERNET_MAXIMUM_INSTANCES) {
		return false;
	}

	// Gets instance
	CPSW_INSTANCE = &ETHERNET_CPSW_INSTANCES[INSTANCE];

	// Verifies instance initialization
	if (!CPSW_INSTANCE->INITIALIZED) {
		return false;
	}

	// Verifies port
	if ((PORT - 1) >= ETHERNET_MAXIMUM_INSTANCE_PORTS) {
		return false;
	}

	// Gets port
	CPSW_PORT = &CPSW_INSTANCE->CPSW_PORTS[PORT - 1];

	// Verifies port initialization
	if (!CPSW_PORT->INITIALIZED) {
		return false;
	}

	// Verifies maximum packet length
	if (LENGTH > ETHERNET_PACKETLENGTH_MAXIMUM) {
		return false;
	}

	// Verifies minimum packet length
	if (LENGTH < ETHERNET_PACKETLENGTH_MINIMUM) {
		LENGTH = ETHERNET_PACKETLENGTH_MINIMUM;
	}

	// Verifies enter critical section flag
	if (ENTER_CRITICAL_SECTION) {

		// Enters critical section
		ETHERNET_HOOK_ENTERCRITICALSECTION();
	}

	// Frees sent packets
	ETHERNET_CPDMA_FREESENTPACKETS(INSTANCE);

	// Verifies free buffer descriptors capacity
	if (LENGTH > (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT * ETHERNET_BUFFERLENGTH)) {

		// Verifies enter critical section flag
		if (ENTER_CRITICAL_SECTION) {

			// Exits critical section
			ETHERNET_HOOK_EXITCRITICALSECTION();
		}
		return false;
	}

	// Initializes current buffer descriptor
	CURRENT_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD;

	// Initializes last buffer descriptor
	LAST_BUFFERDESCRIPTOR = null;

	// Prepares start of packet buffer descriptor
	CURRENT_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH = ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_SOP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_OWNERSHIP_MASK | ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TOPORTENABLE_MASK | (PORT << ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_TOPORT_SHIFT) | (LENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_PACKETLENGTH_MASK);

	// Allocates send buffers
	while (LENGTH > 0) {

		// Calculates buffer packet length
		BUFFER_PACKET_LENGTH = (LENGTH > ETHERNET_BUFFERLENGTH ? ETHERNET_BUFFERLENGTH : LENGTH);

		// Copies packet into buffer
		{

			// Prepares pointer
			BUFFER_PACKET = (unsigned char *) CURRENT_BUFFERDESCRIPTOR->BUFFERPOINTER;

			// Copies packet into buffer
			for (BUFFER_PACKET_INDEX = 0; BUFFER_PACKET_INDEX < BUFFER_PACKET_LENGTH; BUFFER_PACKET_INDEX++) {
				BUFFER_PACKET[BUFFER_PACKET_INDEX] = PACKET[BUFFER_PACKET_INDEX];
			}
		}

		// Counts busy buffer descriptor
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_COUNT--;

		// Decreases length
		LENGTH -= BUFFER_PACKET_LENGTH;

		// Sets last buffer descriptor
		LAST_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR;

		// Moves to next buffer descriptor
		CURRENT_BUFFERDESCRIPTOR = CURRENT_BUFFERDESCRIPTOR->NEXT;
	}

	// Prepares end of packet buffer descriptor
	LAST_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH |= ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_EOP_MASK;

	// Verifies TX busy buffer descriptors queue
	if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD == null) {

		// Inserts allocated buffer descriptors in empty busy queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = LAST_BUFFERDESCRIPTOR;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL->NEXT = null;

		// Removes allocated buffer descriptors from free queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD = CURRENT_BUFFERDESCRIPTOR;
		if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD == null) {
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = null;
		}

		// Sets CPDMA TX head buffer descriptor
		CPSWCPDMATxHdrDescPtrWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, (unsigned int) CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_HEAD, ETHERNET_CPDMA_DEFAULTCHANNEL);
	} else {

		// Gets last enqueued buffer descriptor
		LAST_ENQUEUED_BUFFERDESCRIPTOR = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL;

		// Inserts allocated buffer descriptors in non-empty busy queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL->NEXT = CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL = LAST_BUFFERDESCRIPTOR;
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXBUSY_TAIL->NEXT = null;

		// Removes allocated buffer descriptors from free queue
		CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD = CURRENT_BUFFERDESCRIPTOR;
		if (CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_HEAD == null) {
			CPSW_INSTANCE->CPDMA_BUFFERDESCRIPTORQUEUE_TXFREE_TAIL = null;
		}

		// Verifies last enqueued buffer descriptor end of queue flag
		if (LAST_ENQUEUED_BUFFERDESCRIPTOR->FLAGS_PACKETLENGTH & ETHERNET_CPDMA_BUFFERDESCRIPTOR_TX_FLAGS_EOQ_MASK) {

			// Sets CPDMA TX head buffer descriptor
			CPSWCPDMATxHdrDescPtrWrite(CPSW_INSTANCE->BASEADDRESS_CPDMA, (unsigned int) LAST_ENQUEUED_BUFFERDESCRIPTOR->NEXT, ETHERNET_CPDMA_DEFAULTCHANNEL);
		}
	}

	// Verifies enter critical section flag
	if (ENTER_CRITICAL_SECTION) {

		// Exits critical section
		ETHERNET_HOOK_EXITCRITICALSECTION();
	}

	// Success
	return true;
}
