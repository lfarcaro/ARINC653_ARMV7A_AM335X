// ARINC653 includes
#include "arinc653_core.h"

// Run system error action method
void RUN_SYSTEM_ERROR_ACTION(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER) {
	SYSTEM_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_TYPE ERROR_ACTION;
	SYSTEM_CONFIGURATION_HEALTHMONITORING_TYPE *SYSTEM_CONFIGURATION_HEALTHMONITORING;
	INDEX_TYPE ERROR_INDEX;
	RETURN_CODE_TYPE RETURN_CODE;

	// Verifies enter core flag
	if (ENTERCORE) {

		// Enters core
		ENTER_CORE();
	}

	// Sets default error action
	ERROR_ACTION = SYSTEM_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_RESET;

	// Gets system configuration health monitoring
	SYSTEM_CONFIGURATION_HEALTHMONITORING = SYSTEM_INFORMATION.SYSTEM_CONFIGURATION->SYSTEM_CONFIGURATION_HEALTHMONITORING;

	// Verifies system configuration health monitoring
	if (SYSTEM_CONFIGURATION_HEALTHMONITORING != null) {

		// Iterates system health monitoring errors
		for (ERROR_INDEX = 0; ERROR_INDEX < SYSTEM_CONFIGURATION_HEALTHMONITORING->ERROR_SIZE; ERROR_INDEX++) {

			// Verifies error identifier
			if (SYSTEM_CONFIGURATION_HEALTHMONITORING->ERROR[ERROR_INDEX].ERROR_IDENTIFIER == ERROR_IDENTIFIER) {

				// Gets error action
				ERROR_ACTION = SYSTEM_CONFIGURATION_HEALTHMONITORING->ERROR[ERROR_INDEX].ERROR_ACTION;

				// Error found
				break;
			}
		}
	}

	// Verifies error action
	if (ERROR_ACTION == SYSTEM_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_SHUTDOWN) {

		// Sets module mode
		SET_MODULE_MODE(IDLE, &RETURN_CODE);
	} else if (ERROR_ACTION == SYSTEM_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_RESET) {

		// Sets module mode
		SET_MODULE_MODE(WARM_START, &RETURN_CODE);
	}

	// Verifies enter core flag
	if (ENTERCORE) {

		// Exits core
		EXIT_CORE();
	}
}

// Raise module error method
static void RAISE_MODULE_ERROR(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, PROCESS_ID_TYPE FAILED_PROCESS_ID, SYSTEM_ADDRESS_TYPE FAILED_ADDRESS, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Reports module error
	PORT_REPORTMODULEERROR(SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH);

	// Verifies current system state
	if (SYSTEM_STATE == SYSTEMSTATE_MODULEHEALTHMONITORINGCALLBACK) {

		// Runs module error action
		RUN_MODULE_ERROR_ACTION(ENTERCORE, YIELD, SYSTEM_STATE, ERROR_IDENTIFIER);

		// Runs system error action - Only reached if module error action is IGNORE
		RUN_SYSTEM_ERROR_ACTION(ENTERCORE, YIELD, SYSTEM_STATE, ERROR_IDENTIFIER);

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;
		return;
	}

	// Verifies health monitoring callback
	if (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.EXISTS) {

		// Starts health monitoring callback
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT = SYSTEM_PARTITION_CONTEXT;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START = true;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE = SYSTEM_STATE;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER = ERROR_IDENTIFIER;

		// Verifies yield flag
		if (YIELD) {

			// Yields
			PORT_YIELD();
		}
	} else {

		// Runs module error action
		RUN_MODULE_ERROR_ACTION(ENTERCORE, YIELD, SYSTEM_STATE, ERROR_IDENTIFIER);
	}

	// Sets return code
	*RETURN_CODE = NO_ERROR;
}

// Run module error action method
void RUN_MODULE_ERROR_ACTION(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	MODULE_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_TYPE ERROR_ACTION;
	MODULE_CONFIGURATION_HEALTHMONITORING_TYPE *MODULE_CONFIGURATION_HEALTHMONITORING;
	INDEX_TYPE SYSTEMSTATE_INDEX;
	INDEX_TYPE ERROR_INDEX;
	RETURN_CODE_TYPE RETURN_CODE;

	// Verifies enter core flag
	if (ENTERCORE) {

		// Enters core
		ENTER_CORE();
	}

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Sets default error action
	ERROR_ACTION = MODULE_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_IGNORE;

	// Gets module configuration health monitoring
	MODULE_CONFIGURATION_HEALTHMONITORING = MODULE_INFORMATION->MODULE_CONFIGURATION->MODULE_CONFIGURATION_HEALTHMONITORING;

	// Verifies module configuration health monitoring
	if (MODULE_CONFIGURATION_HEALTHMONITORING != null) {

		// Iterates module configuration health monitoring system states
		for (SYSTEMSTATE_INDEX = 0; SYSTEMSTATE_INDEX < MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE_SIZE; SYSTEMSTATE_INDEX++) {

			// Verifies system state
			if (MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].SYSTEM_STATE == SYSTEM_STATE) {

				// Iterates module configuration health monitoring system state errors
				for (ERROR_INDEX = 0; ERROR_INDEX < MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR_SIZE; ERROR_INDEX++) {

					// Verifies error identifier
					if (MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_IDENTIFIER == ERROR_IDENTIFIER) {

						// Gets error action
						ERROR_ACTION = MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_ACTION;

						// Error found
						break;
					}
				}

				// System state found
				break;
			}
		}
	}

	// Verifies error action
	if (ERROR_ACTION == MODULE_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_IGNORE) {

		// No action
	} else if (ERROR_ACTION == MODULE_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_SHUTDOWN) {

		// Sets module mode
		SET_MODULE_MODE(IDLE, &RETURN_CODE);
	} else if (ERROR_ACTION == MODULE_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_RESET) {

		// Cannot change from COLD_START to WARM_START
		if (MODULE_INFORMATION->OPERATING_MODE == COLD_START) {

			// Sets module mode
			SET_MODULE_MODE(COLD_START, &RETURN_CODE);
		} else {

			// Sets module mode
			SET_MODULE_MODE(WARM_START, &RETURN_CODE);
		}
	}

	// Verifies enter core flag
	if (ENTERCORE) {

		// Exits core
		EXIT_CORE();
	}
}

// Stop module health monitoring callback method
void STOP_MODULE_HEALTHMONITORINGCALLBACK(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;

	// Enters core
	ENTER_CORE();

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Stops module health monitoring callback
	MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = true;

	// Yields
	PORT_YIELD();

	// Exits core
	EXIT_CORE();
}

// Raise partition error method
static void RAISE_PARTITION_ERROR(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, PROCESS_ID_TYPE FAILED_PROCESS_ID, SYSTEM_ADDRESS_TYPE FAILED_ADDRESS, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Reports partition error
	PORT_REPORTPARTITIONERROR(SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH);

	// Verifies current system state
	if (SYSTEM_STATE == SYSTEMSTATE_PARTITIONHEALTHMONITORINGCALLBACK) {

		// Runs partition error action
		RUN_PARTITION_ERROR_ACTION(ENTERCORE, YIELD, SYSTEM_STATE, ERROR_IDENTIFIER);

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;
		return;
	}

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;
		return;
	}

	// Verifies health monitoring callback
	if (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.EXISTS) {

		// Starts health monitoring callback
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT = SYSTEM_PARTITION_CONTEXT;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START = true;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE = SYSTEM_STATE;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER = ERROR_IDENTIFIER;

		// Verifies yield flag
		if (YIELD) {

			// Yields
			PORT_YIELD();
		}
	} else {

		// Runs partition error action
		RUN_PARTITION_ERROR_ACTION(ENTERCORE, YIELD, SYSTEM_STATE, ERROR_IDENTIFIER);
	}

	// Sets return code
	*RETURN_CODE = NO_ERROR;
}

// Run partition error action method
void RUN_PARTITION_ERROR_ACTION(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_TYPE ERROR_ACTION;
	PARTITION_CONFIGURATION_HEALTHMONITORING_TYPE *PARTITION_CONFIGURATION_HEALTHMONITORING;
	INDEX_TYPE SYSTEMSTATE_INDEX;
	INDEX_TYPE ERROR_INDEX;
	RETURN_CODE_TYPE RETURN_CODE;

	// Verifies enter core flag
	if (ENTERCORE) {

		// Enters core
		ENTER_CORE();
	}

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Sets default error action
	ERROR_ACTION = PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_IGNORE;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION != null) {

		// Gets configuration partition health monitoring
		PARTITION_CONFIGURATION_HEALTHMONITORING = _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_HEALTHMONITORING;

		// Verifies partition configuration health monitoring
		if (PARTITION_CONFIGURATION_HEALTHMONITORING != null) {

			// Iterates partition configuration health monitoring system states
			for (SYSTEMSTATE_INDEX = 0; SYSTEMSTATE_INDEX < PARTITION_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE_SIZE; SYSTEMSTATE_INDEX++) {

				// Verifies system state
				if (PARTITION_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].SYSTEM_STATE == SYSTEM_STATE) {

					// Iterates partition configuration health monitoring system state errors
					for (ERROR_INDEX = 0; ERROR_INDEX < PARTITION_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR_SIZE; ERROR_INDEX++) {

						// Verifies error identifier
						if (PARTITION_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_IDENTIFIER == ERROR_IDENTIFIER) {

							// Gets error action
							ERROR_ACTION = PARTITION_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_ACTION;

							// Error found
							break;
						}
					}

					// System state found
					break;
				}
			}
		}

		// Verifies error action
		if (ERROR_ACTION == PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_IGNORE) {

			// No action
		} else if (ERROR_ACTION == PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_IDLE) {

			// Sets partition mode
			SET_PARTITION_MODE(IDLE, &RETURN_CODE);
		} else if (ERROR_ACTION == PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_WARM_START) {

			// Sets health monitoring partition restart flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORING_PARTITION_RESTART = true;

			// Cannot change from COLD_START to WARM_START
			if (_CURRENT_PARTITION_INFORMATION->OPERATING_MODE == COLD_START) {

				// Sets partition mode
				SET_PARTITION_MODE(COLD_START, &RETURN_CODE);
			} else {

				// Sets partition mode
				SET_PARTITION_MODE(WARM_START, &RETURN_CODE);
			}

			// Resets health monitoring partition restart flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORING_PARTITION_RESTART = false;
		} else if (ERROR_ACTION == PARTITION_CONFIGURATION_HEALTHMONITORING_ERROR_ACTION_COLD_START) {

			// Sets health monitoring partition restart flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORING_PARTITION_RESTART = true;

			// Sets partition mode
			SET_PARTITION_MODE(COLD_START, &RETURN_CODE);

			// Resets health monitoring partition restart flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORING_PARTITION_RESTART = false;
		}
	}

	// Verifies enter core flag
	if (ENTERCORE) {

		// Exits core
		EXIT_CORE();
	}
}

// Stop partition health monitoring callback method
void STOP_PARTITION_HEALTHMONITORINGCALLBACK(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;

	// Enters core
	ENTER_CORE();

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Stops partition health monitoring callback
	_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = true;

	// Yields
	PORT_YIELD();

	// Exits core
	EXIT_CORE();
}

// Raise process error method
static void RAISE_PROCESS_ERROR(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, PROCESS_ID_TYPE FAILED_PROCESS_ID, SYSTEM_ADDRESS_TYPE FAILED_ADDRESS, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	ERRORHANDLER_INFORMATION_TYPE *ERRORHANDLER_INFORMATION;
	INDEX_TYPE ERROR_STATUS_INDEX;
	INDEX_TYPE CHARACTER_INDEX;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Reports process error
	PORT_REPORTPROCESSERROR(SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS);

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;
		return;
	}

	// Verifies length
	if (LENGTH > MAX_ERROR_MESSAGE_SIZE) {

		// Sets return code
		*RETURN_CODE = INVALID_PARAM;
		return;
	}

	// Gets error handler information
	ERRORHANDLER_INFORMATION = &_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION;

	// Verifies error handler existence and state
	if ((!ERRORHANDLER_INFORMATION->EXISTS) || (ERRORHANDLER_INFORMATION->RUNNING)) {

		// Raises partition error
		RAISE_PARTITION_ERROR(ENTERCORE, YIELD, SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS, RETURN_CODE);
		return;
	}

	// Verifies available error status entries
	if (_CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT < _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->MAXIMUM_ERRORSTATUS_COUNT) {

		// Calculates error status index
		ERROR_STATUS_INDEX = _CURRENT_PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX + _CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT;

		// Fixes error status index
		if (ERROR_STATUS_INDEX >= _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->MAXIMUM_ERRORSTATUS_COUNT) {
			ERROR_STATUS_INDEX -= _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->MAXIMUM_ERRORSTATUS_COUNT;
		}

		// Fills error status
		_CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].ERROR_CODE = ERROR_CODE;
		for (CHARACTER_INDEX = 0; CHARACTER_INDEX < LENGTH; CHARACTER_INDEX++) {
			_CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].MESSAGE[CHARACTER_INDEX] = MESSAGE_ADDR[CHARACTER_INDEX];
		}
		_CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].LENGTH = LENGTH;
		_CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].FAILED_PROCESS_ID = FAILED_PROCESS_ID;
		_CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].FAILED_ADDRESS = FAILED_ADDRESS;

		// Increases error status count
		_CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT++;
	}

	// Starts error handler
	_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.SYSTEM_PARTITION_CONTEXT = SYSTEM_PARTITION_CONTEXT;
	_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START = true;
	_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.STOP = false;

	// Verifies yield flag
	if (YIELD) {

		// Yields
		PORT_YIELD();
	}

	// Sets return code
	*RETURN_CODE = NO_ERROR;
}

// Raise error method
void RAISE_ERROR(BOOLEAN_TYPE ENTERCORE, BOOLEAN_TYPE YIELD, BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE_TYPE SYSTEM_STATE, ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER, ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, PROCESS_ID_TYPE FAILED_PROCESS_ID, SYSTEM_ADDRESS_TYPE FAILED_ADDRESS, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	ERROR_LEVEL_TYPE ERROR_LEVEL;
	MODULE_CONFIGURATION_HEALTHMONITORING_TYPE *MODULE_CONFIGURATION_HEALTHMONITORING;
	INDEX_TYPE SYSTEMSTATE_INDEX;
	INDEX_TYPE ERROR_INDEX;

	// Verifies enter core flag
	if (ENTERCORE) {

		// Enters core
		ENTER_CORE();
	}

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Initializes error level
	ERROR_LEVEL = (ERROR_LEVEL_TYPE) null;

	// Gets module configuration health monitoring
	MODULE_CONFIGURATION_HEALTHMONITORING = MODULE_INFORMATION->MODULE_CONFIGURATION->MODULE_CONFIGURATION_HEALTHMONITORING;

	// Verifies module configuration health monitoring
	if (MODULE_CONFIGURATION_HEALTHMONITORING != null) {

		// Iterates module configuration health monitoring system states
		for (SYSTEMSTATE_INDEX = 0; SYSTEMSTATE_INDEX < MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE_SIZE; SYSTEMSTATE_INDEX++) {

			// Verifies current system state
			if (MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].SYSTEM_STATE == SYSTEM_STATE) {

				// Iterates module configuration health monitoring system state errors
				for (ERROR_INDEX = 0; ERROR_INDEX < MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR_SIZE; ERROR_INDEX++) {

					// Verifies error identifier
					if (MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_IDENTIFIER == ERROR_IDENTIFIER) {

						// Gets error level
						ERROR_LEVEL = MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_LEVEL;

						// Verifies error code
						if (MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_CODE != null) {

							// Gets error code
							ERROR_CODE = MODULE_CONFIGURATION_HEALTHMONITORING->SYSTEMSTATE[SYSTEMSTATE_INDEX].ERROR[ERROR_INDEX].ERROR_CODE;
						}

						// Error found
						break;
					}
				}

				// System state found
				break;
			}
		}
	}

	// Verifies error level
	if ((ERROR_LEVEL == ERROR_LEVEL_PROCESS) && (ERROR_CODE != null)) {

		// Verifies current partition information
		if (_CURRENT_PARTITION_INFORMATION == null) {

			// Sets return code
			*RETURN_CODE = INVALID_CONFIG;

			// Verifies enter core flag
			if (ENTERCORE) {

				// Exits core
				EXIT_CORE();
			}
			return;
		}

		// Raises process error
		RAISE_PROCESS_ERROR(ENTERCORE, YIELD, SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS, RETURN_CODE);

		// Verifies enter core flag
		if (ENTERCORE) {

			// Exits core
			EXIT_CORE();
		}
		return;
	} else if (ERROR_LEVEL == ERROR_LEVEL_PARTITION) {

		// Verifies current partition information
		if (_CURRENT_PARTITION_INFORMATION == null) {

			// Sets return code
			*RETURN_CODE = INVALID_CONFIG;

			// Verifies enter core flag
			if (ENTERCORE) {

				// Exits core
				EXIT_CORE();
			}
			return;
		}

		// Raises partition error
		RAISE_PARTITION_ERROR(ENTERCORE, YIELD, SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS, RETURN_CODE);

		// Verifies enter core flag
		if (ENTERCORE) {

			// Exits core
			EXIT_CORE();
		}
		return;
	} else if (ERROR_LEVEL == ERROR_LEVEL_MODULE) {

		// Raises module error
		RAISE_MODULE_ERROR(ENTERCORE, YIELD, SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE, ERROR_IDENTIFIER, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS, RETURN_CODE);

		// Verifies enter core flag
		if (ENTERCORE) {

			// Exits core
			EXIT_CORE();
		}
		return;
	}

	// Sets return code
	*RETURN_CODE = INVALID_CONFIG;

	// Verifies enter core flag
	if (ENTERCORE) {

		// Exits core
		EXIT_CORE();
	}
}

// Report application message method
void REPORT_APPLICATION_MESSAGE(MESSAGE_ADDR_TYPE MESSAGE_ADDR, MESSAGE_SIZE_TYPE LENGTH, RETURN_CODE_TYPE *RETURN_CODE) {

	// Enters core
	ENTER_CORE();

	// Verifies length
	if (LENGTH > MAX_APPLICATION_MESSAGE_SIZE) {

		// Sets return code
		*RETURN_CODE = INVALID_PARAM;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Reports application message
	PORT_REPORTAPPLICATIONMESSAGE(MESSAGE_ADDR, LENGTH);

	// Sets return code
	*RETURN_CODE = NO_ERROR;

	// Exits core
	EXIT_CORE();
}

// Create error handler method
void CREATE_ERROR_HANDLER(SYSTEM_ADDRESS_TYPE ENTRY_POINT, STACK_SIZE_TYPE STACK_SIZE, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	ERRORHANDLER_INFORMATION_TYPE *ERRORHANDLER_INFORMATION;

	// Enters core
	ENTER_CORE();

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {

		// Sets return code
		*RETURN_CODE = INVALID_MODE;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Verifies operating mode
	if (_CURRENT_PARTITION_INFORMATION->OPERATING_MODE == NORMAL) {

		// Sets return code
		*RETURN_CODE = INVALID_MODE;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Gets error handler information
	ERRORHANDLER_INFORMATION = &_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION;

	// Verifies error handler existence
	if (ERRORHANDLER_INFORMATION->EXISTS) {

		// Sets return code
		*RETURN_CODE = NO_ACTION;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Verifies error handler stack configuration
	if ((_CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_ADDRESS == null) || (_CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_SIZE == null)) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Calls hook
	if (!PORT_HOOK_BEFORE_CREATE_ERROR_HANDLER(_CURRENT_PARTITION_INFORMATION, ERRORHANDLER_INFORMATION)) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Sets up error handler
	ERRORHANDLER_INFORMATION->EXISTS = true;
	ERRORHANDLER_INFORMATION->ENTRY_POINT = ENTRY_POINT;
	ERRORHANDLER_INFORMATION->STACK_SIZE = STACK_SIZE;
	if (ERRORHANDLER_INFORMATION->CONTEXT.IDENTIFIER == null) {
		ERRORHANDLER_INFORMATION->CONTEXT.IDENTIFIER = (MODULE_INFORMATION->NEXT_CONTEXT_IDENTIFIER++);
	}
	ERRORHANDLER_INFORMATION->CONTEXT.STACK_BOTTOM = _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_ADDRESS;
	ERRORHANDLER_INFORMATION->CONTEXT.STACK_TOP = (STACKROW_TYPE *) ((UINTPOINTER_TYPE) ERRORHANDLER_INFORMATION->CONTEXT.STACK_BOTTOM + (UINTPOINTER_TYPE) _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_ERRORHANDLER_STACK_SIZE);
	ERRORHANDLER_INFORMATION->CONTEXT.CORE_DEPTH = 0;
	ERRORHANDLER_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT = _CURRENT_PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT;
	ERRORHANDLER_INFORMATION->CONTEXT.ENTRY_POINT = ENTRY_POINT;
	ERRORHANDLER_INFORMATION->CONTEXT.RETURN_POINT = &RETURNPOINT_PARTITIONERRORHANDLER;
	ERRORHANDLER_INFORMATION->CONTEXT.PARAMETER1 = null;
	ERRORHANDLER_INFORMATION->CONTEXT.PARAMETER2 = null;

	// Verifies error handler context identifier
	if (ERRORHANDLER_INFORMATION->CONTEXT.IDENTIFIER > MODULE_INFORMATION->LAST_CONTEXT_IDENTIFIER) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Calls hook
	if (!PORT_HOOK_AFTER_CREATE_ERROR_HANDLER(_CURRENT_PARTITION_INFORMATION, ERRORHANDLER_INFORMATION)) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Sets return code
	*RETURN_CODE = NO_ERROR;

	// Exits core
	EXIT_CORE();
}

// Get error status method
void GET_ERROR_STATUS(ERROR_STATUS_TYPE *ERROR_STATUS, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	INDEX_TYPE ERROR_STATUS_INDEX;
	INDEX_TYPE CHARACTER_INDEX;

	// Enters core
	ENTER_CORE();

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {

		// Sets return code
		*RETURN_CODE = INVALID_MODE;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Verifies error handler state
	if (!_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING) {

		// Sets return code
		*RETURN_CODE = INVALID_CONFIG;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Verifies available error status entries
	if (_CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT == 0) {

		// Sets return code
		*RETURN_CODE = NO_ACTION;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Gets error status index
	ERROR_STATUS_INDEX = _CURRENT_PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX;

	// Fills error status
	ERROR_STATUS->ERROR_CODE = _CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].ERROR_CODE;
	ERROR_STATUS->LENGTH = _CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].LENGTH;
	for (CHARACTER_INDEX = 0; CHARACTER_INDEX < ERROR_STATUS->LENGTH; CHARACTER_INDEX++) {
		ERROR_STATUS->MESSAGE[CHARACTER_INDEX] = _CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].MESSAGE[CHARACTER_INDEX];
	}
	ERROR_STATUS->FAILED_PROCESS_ID = _CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].FAILED_PROCESS_ID;
	ERROR_STATUS->FAILED_ADDRESS = _CURRENT_PARTITION_INFORMATION->ERROR_STATUS[ERROR_STATUS_INDEX].FAILED_ADDRESS;

	// Moves next error status
	_CURRENT_PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX++;

	// Fixes next error status
	if (_CURRENT_PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX >= _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->MAXIMUM_ERRORSTATUS_COUNT) {
		_CURRENT_PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX = 0;
	}

	// Decreases error status count
	_CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT--;

	// Sets return code
	*RETURN_CODE = NO_ERROR;

	// Exits core
	EXIT_CORE();
}

// Raise application error method
void RAISE_APPLICATION_ERROR(ERROR_CODE_TYPE ERROR_CODE, MESSAGE_ADDR_TYPE MESSAGE_ADDR, ERROR_MESSAGE_SIZE_TYPE LENGTH, RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	CONTEXT_TYPE *CURRENT_CONTEXT;
	SYSTEM_ADDRESS_TYPE FAILED_ADDRESS;
	BOOLEAN_TYPE SYSTEM_PARTITION_CONTEXT;
	PROCESS_ID_TYPE FAILED_PROCESS_ID;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Gets current context
	CURRENT_CONTEXT = _CORE_CURRENT_CONTEXT;

	// Prepares call address
	PORT_PREPARECALLADDRESS();

	// Gets call address
	FAILED_ADDRESS = PORT_GETCALLADDRESS();

	// Enters core
	ENTER_CORE();

	// Verifies error code
	if (ERROR_CODE != APPLICATION_ERROR) {

		// Sets return code
		*RETURN_CODE = INVALID_PARAM;

		// Exits core
		EXIT_CORE();
		return;
	}

	// Gets failed process identifier
	if (_CURRENT_PARTITION_INFORMATION != null) {
		SYSTEM_PARTITION_CONTEXT = _CURRENT_PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT;
		if (_CURRENT_PROCESS_INFORMATION != null) {
			FAILED_PROCESS_ID = _CURRENT_PROCESS_INFORMATION->IDENTIFIER;
		} else {
			FAILED_PROCESS_ID = INVALID_IDENTIFIER;
		}
	} else {
		SYSTEM_PARTITION_CONTEXT = false;
		FAILED_PROCESS_ID = INVALID_IDENTIFIER;
	}

	// Raises error
	RAISE_ERROR(true, true, SYSTEM_PARTITION_CONTEXT, CURRENT_CONTEXT->DEFAULT_SYSTEM_STATE, ERRORIDENTIFIER_APPLICATIONERROR, ERROR_CODE, MESSAGE_ADDR, LENGTH, FAILED_PROCESS_ID, FAILED_ADDRESS, RETURN_CODE);

	// Exits core
	EXIT_CORE();
}
