// ARINC653 includes
#include "arinc653_core.h"

// Schedule partition out method
static BOOLEAN_TYPE SCHEDULER_SCHEDULEPARTITIONOUT(MODULE_INFORMATION_TYPE *MODULE_INFORMATION) {
	priorityqueueENTRY *ENT_PARTITIONREADY;
	PARTITION_ID_TYPE PARTITION_IDENTIFIER;
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;

	// Verifies module health monitoring callback running flag
	if (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING) {

		// Verifies stop module health monitoring callback flag
		if (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP) {

			// Sets next context to module default partition context
			_CORE_NEXT_CONTEXT = &MODULE_INFORMATION->CONTEXT;

			// Sets module health monitoring callback running flag
			MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = false;

			// Sets stop module health monitoring callback flag
			MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
			return false;
		}

		// High priority task running
		return false;
	}

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {
		return false;
	}

	// Verifies operating mode
	if (MODULE_INFORMATION->OPERATING_MODE != NORMAL) {
		return false;
	}

	// Verifies module start health monitoring callback flag
	if (!MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) {

		// Verifies partition ready priority queue
		if (!PRIORITYQUEUE_ISEMPTY(&MODULE_INFORMATION->REC_PARTITIONREADY)) {

			// Gets partition ready priority queue head
			ENT_PARTITIONREADY = MODULE_INFORMATION->REC_PARTITIONREADY.ENT_HEAD;

			// Gets ready partition identifier
			PARTITION_IDENTIFIER = (PARTITION_ID_TYPE) ENT_PARTITIONREADY->VAL_VALUE;

			// Gets partition information
			PARTITION_INFORMATION = &MODULE_INFORMATION->PARTITION_INFORMATION[PARTITION_IDENTIFIER];

			// Verifies partition to be scheduled
			if (PARTITION_IDENTIFIER == _CURRENT_PARTITION_INFORMATION->IDENTIFIER) {

				// Verifies partition stop time
				if (MODULE_INFORMATION->MAJOR_FRAME_TIME < (PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].START + PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].DURATION)) {
					return false;
				}

				// Removes priority queue entries
				PRIORITYQUEUE_REMOVE(&PARTITION_INFORMATION->ENT_PARTITIONREADY);

				// Moves schedule window index
				PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX++;

				// Verifies partition schedule finish
				if (PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX < PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW_SIZE) {

					// Fills partition ready priority queue entry
					ENT_PARTITIONREADY->PRI_PRIORITY = (priorityqueuePRIORITY) PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].START;
					ENT_PARTITIONREADY->VAL_VALUE = (priorityqueueVALUE) PARTITION_INFORMATION->IDENTIFIER;

					// Enqueues partition ready priority queue entry
					PRIORITYQUEUE_ENQUEUE(&MODULE_INFORMATION->REC_PARTITIONREADY, ENT_PARTITIONREADY);
				}
			}
		}
	}

	// Sets next context to module default partition context
	_CORE_NEXT_CONTEXT = &MODULE_INFORMATION->CONTEXT;

	// Sets current partition information
	MODULE_INFORMATION->CURRENT_PARTITION_INFORMATION = null;

	// Partition scheduled out
	return true;
}

// Schedule partition in method
static BOOLEAN_TYPE SCHEDULER_SCHEDULEPARTITIONIN(MODULE_INFORMATION_TYPE *MODULE_INFORMATION) {
	priorityqueueENTRY *ENT_PARTITIONREADY;
	PARTITION_ID_TYPE PARTITION_IDENTIFIER;
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION != null) {
		return false;
	}

	// Verifies module health monitoring callback running flag
	if (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING) {
		return false;
	}

	// Verifies start module health monitoring callback flag
	if (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) {

		// Sets context attributes
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER1 = MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE;
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER2 = MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER;

		// Prepares module health monitoring callback context
		PORT_PREPARECONTEXT(&MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT);

		// Resets module health monitoring callback context system state
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_STATE = MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.DEFAULT_SYSTEM_STATE;

		// Sets next context to module health monitoring callback context
		_CORE_NEXT_CONTEXT = &MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT;

		// Sets module health monitoring callback running flag
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = true;

		// Sets start module health monitoring callback flag
		MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START = false;
		return false;
	}

	// Verifies operating mode
	if (MODULE_INFORMATION->OPERATING_MODE != NORMAL) {
		return false;
	}

	// Verifies partition ready priority queue
	if (PRIORITYQUEUE_ISEMPTY(&MODULE_INFORMATION->REC_PARTITIONREADY)) {
		return false;
	}

	// Gets partition ready priority queue head
	ENT_PARTITIONREADY = MODULE_INFORMATION->REC_PARTITIONREADY.ENT_HEAD;

	// Gets ready partition identifier
	PARTITION_IDENTIFIER = (PARTITION_ID_TYPE) ENT_PARTITIONREADY->VAL_VALUE;

	// Gets partition information
	PARTITION_INFORMATION = &MODULE_INFORMATION->PARTITION_INFORMATION[PARTITION_IDENTIFIER];

	// Verifies partition start time
	if (MODULE_INFORMATION->MAJOR_FRAME_TIME < PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].START) {
		return false;
	}

	// Sets current partition information
	MODULE_INFORMATION->CURRENT_PARTITION_INFORMATION = PARTITION_INFORMATION;

	// Verifies current process information
	if (_CURRENT_PROCESS_INFORMATION != null) {

		// Sets next context to process context
		_CORE_NEXT_CONTEXT = &_CURRENT_PROCESS_INFORMATION->CONTEXT;
	} else {

		// Verifies partition health monitoring callback running flag
		if (PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING) {

			// Sets next context to partition health monitoring callback context
			_CORE_NEXT_CONTEXT = &PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT;
		} else {

			// Verifies error handler running flag
			if (PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING) {

				// Sets next context to error handler context
				_CORE_NEXT_CONTEXT = &PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT;
			} else {

				// Sets next context to partition default process context
				_CORE_NEXT_CONTEXT = &PARTITION_INFORMATION->CONTEXT;
			}
		}
	}

	// Partition scheduled in
	return true;
}

// Start partition scheduler method
void SCHEDULER_STARTPARTITIONSCHEDULER(RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	PARTITION_ID_TYPE PARTITION_IDENTIFIER;
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Verifies partition count
	if (MODULE_INFORMATION->PARTITION_COUNT == 0) {

		// Sets return code
		*RETURN_CODE = NO_ERROR;
		return;
	}

	// Iterates partitions
	for (PARTITION_IDENTIFIER = 0; PARTITION_IDENTIFIER < MODULE_INFORMATION->PARTITION_COUNT; PARTITION_IDENTIFIER++) {

		// Gets partition information
		PARTITION_INFORMATION = &MODULE_INFORMATION->PARTITION_INFORMATION[PARTITION_IDENTIFIER];

		// Sets operating mode
		PARTITION_INFORMATION->OPERATING_MODE = COLD_START;

		// Prepares partition default process context
		PORT_PREPARECONTEXT(&PARTITION_INFORMATION->CONTEXT);

		// Resets partition default process context system state
		PARTITION_INFORMATION->CONTEXT.SYSTEM_STATE = PARTITION_INFORMATION->CONTEXT.DEFAULT_SYSTEM_STATE;

		// Initializes partition schedule
		PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX = 0;

		// Fills partition ready priority queue entry
		PARTITION_INFORMATION->ENT_PARTITIONREADY.PRI_PRIORITY = (priorityqueuePRIORITY) PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].START;
		PARTITION_INFORMATION->ENT_PARTITIONREADY.VAL_VALUE = (priorityqueueVALUE) PARTITION_INFORMATION->IDENTIFIER;

		// Enqueues partition ready priority queue entry
		PRIORITYQUEUE_ENQUEUE(&MODULE_INFORMATION->REC_PARTITIONREADY, &PARTITION_INFORMATION->ENT_PARTITIONREADY);
	}

	// Sets current partition information
	MODULE_INFORMATION->CURRENT_PARTITION_INFORMATION = null;

	// Starts up clock
	CLOCK_STARTUP();

	// Initializes tick
	PORT_INITIALIZETICK();

#ifdef TRACK
	// Initializes tracking
	TRACK_STARTUP();
#endif

	// Starts scheduler
	PORT_STARTSCHEDULER();

	// Sets return code
	*RETURN_CODE = NO_ERROR;
}

// Handle processes events method
static void SCHEDULER_HANDLEPROCESSESEVENTS(MODULE_INFORMATION_TYPE *MODULE_INFORMATION, SYSTEM_STATE_TYPE SYSTEM_STATE) {
	priorityqueueENTRY *ENT_PROCESS;
	PROCESS_ID_TYPE PROCESS_IDENTIFIER;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;
	RETURN_CODE_TYPE RETURN_CODE;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {
		return;
	}

	// Verifies operating mode
	if (_CURRENT_PARTITION_INFORMATION->OPERATING_MODE != NORMAL) {
		return;
	}

	// Verifies module health monitoring callback start and running flags
	if ((MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) || (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING)) {
		return;
	}

	// Verifies partition health monitoring callback start and running flags
	if ((_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) || (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING)) {
		return;
	}

	// Verifies error handler start and running flags
	if ((_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START) || (_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING)) {
		return;
	} else if (_CURRENT_PARTITION_INFORMATION->ERROR_STATUS_COUNT > 0) {

		// If error handler did not handle all of the errors, it must run again
		// Errors may occur during error handler, but after its error handling loop
		_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START = true;
		return;
	}

	// Process waiting timeout handling loop
	while (true) {

		// Verifies process waiting timeout priority queue
		if (PRIORITYQUEUE_ISEMPTY(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT)) {
			break;
		}

		// Gets process waiting timeout priority queue head
		ENT_PROCESS = _CURRENT_PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT.ENT_HEAD;

		// Verifies process release time
		if (CLOCK_GETSYSTEMTIME() < (SYSTEM_TIME_TYPE) ENT_PROCESS->PRI_PRIORITY) {
			break;
		}

		// Gets waiting process identifier
		PROCESS_IDENTIFIER = (PROCESS_ID_TYPE) ENT_PROCESS->VAL_VALUE;

		// Gets process information
		PROCESS_INFORMATION = &_CURRENT_PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

		// Removes priority queue entries
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT);
		if (PRIORITYQUEUE_ISENQUEUED(&PROCESS_INFORMATION->ENT_PROCESSWAITING_RESOURCE)) {
			PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSWAITING_RESOURCE);
		}

		// Sets wake time
		PROCESS_INFORMATION->WAKE_TIME = CLOCK_GETSYSTEMTIME();

		// Verifies suspension flags
		if ((!PROCESS_INFORMATION->SUSPENDED) || (PROCESS_INFORMATION->SUSPENDED_TIMEOUT)) {

			// Sets process state
			PROCESS_INFORMATION->PROCESS_STATE = READY;

			// Fills process ready priority queue entry
			PROCESS_INFORMATION->ENT_PROCESSREADY.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->CURRENT_PRIORITY;
			PROCESS_INFORMATION->ENT_PROCESSREADY.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

			// Enqueues process ready priority queue entry
			PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY, &PROCESS_INFORMATION->ENT_PROCESSREADY);
		}

		// Verifies deadline time
		if ((PROCESS_INFORMATION->DEADLINE_TIME != INFINITE_TIME_VALUE) && (!PRIORITYQUEUE_ISENQUEUED(&PROCESS_INFORMATION->ENT_PROCESSDEADLINE))) {

			// Fills process deadline priority queue entry
			PROCESS_INFORMATION->ENT_PROCESSDEADLINE.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->DEADLINE_TIME;
			PROCESS_INFORMATION->ENT_PROCESSDEADLINE.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

			// Enqueues process deadline priority queue entry
			PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSDEADLINE, &PROCESS_INFORMATION->ENT_PROCESSDEADLINE);
		}
	}

	// Process deadline handling loop
	while (true) {

		// Verifies process deadline priority queue
		if (PRIORITYQUEUE_ISEMPTY(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSDEADLINE)) {
			break;
		}

		// Gets process deadline priority queue head
		ENT_PROCESS = _CURRENT_PARTITION_INFORMATION->REC_PROCESSDEADLINE.ENT_HEAD;

		// Verifies deadline time
		if (CLOCK_GETSYSTEMTIME() < (SYSTEM_TIME_TYPE) ENT_PROCESS->PRI_PRIORITY) {
			break;
		}

		// Gets deadline process identifier
		PROCESS_IDENTIFIER = (PROCESS_ID_TYPE) ENT_PROCESS->VAL_VALUE;

		// Gets process information
		PROCESS_INFORMATION = &_CURRENT_PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

		// Removes priority queue entries
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSDEADLINE);

		// Sets deadline time
		PROCESS_INFORMATION->DEADLINE_TIME = INFINITE_TIME_VALUE;

		// Raises error
		RAISE_ERROR(false, false, _CURRENT_PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT, SYSTEM_STATE, ERRORIDENTIFIER_DEADLINEMISSED, DEADLINE_MISSED, (MESSAGE_ADDR_TYPE) "DEADLINE MISSED", 15, PROCESS_IDENTIFIER, null, &RETURN_CODE);
	}
}

// Schedule process out method
static void SCHEDULER_SCHEDULEPROCESSOUT(MODULE_INFORMATION_TYPE *MODULE_INFORMATION) {
	priorityqueueENTRY *ENT_PROCESSREADY;
	PROCESS_ID_TYPE PROCESS_IDENTIFIER;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {
		return;
	}

	// Verifies module health monitoring callback start and running flags
	if ((MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) || (MODULE_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING)) {
		return;
	}

	// Verifies partition health monitoring callback running flag
	if (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING) {

		// Verifies stop partition health monitoring callback flag
		if (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP) {

			// Sets next context to partition default process context
			_CORE_NEXT_CONTEXT = &_CURRENT_PARTITION_INFORMATION->CONTEXT;

			// Sets partition health monitoring callback running flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = false;

			// Sets stop partition health monitoring callback flag
			_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
			return;
		}

		// High priority task running
		return;
	}

	// Verifies operating mode
	if (_CURRENT_PARTITION_INFORMATION->OPERATING_MODE != NORMAL) {
		return;
	}

	// Verifies error handler running flag
	if (_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING) {

		// Verifies stop error handler flag
		if (_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.STOP) {

			// Sets error handler preempted process identifier
			_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.PREEMPTED_PROCESS_IDENTIFIER = INVALID_IDENTIFIER;

			// Sets next context to partition default process context
			_CORE_NEXT_CONTEXT = &_CURRENT_PARTITION_INFORMATION->CONTEXT;

			// Sets error handler running flag
			_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING = false;

			// Sets stop error handler flag
			_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.STOP = false;
			return;
		}

		// High priority task running
		return;
	}

	// Verifies current process information
	if (_CURRENT_PROCESS_INFORMATION == null) {
		return;
	}

	// Verifies start partition health monitoring callback flag
	if (!_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) {

		// Verifies start error handler flag
		if (!_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START) {

			// Verifies lock level
			if (_CURRENT_PARTITION_INFORMATION->LOCK_LEVEL > 0) {
				return;
			}

			// Verifies process ready priority queue
			if (!PRIORITYQUEUE_ISEMPTY(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY)) {

				// Gets process ready priority queue head
				ENT_PROCESSREADY = _CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY.ENT_HEAD;

				// Gets ready process identifier
				PROCESS_IDENTIFIER = (PROCESS_ID_TYPE) ENT_PROCESSREADY->VAL_VALUE;

				// Gets process information
				PROCESS_INFORMATION = &_CURRENT_PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

				// Verifies process to be scheduled
				if (PROCESS_IDENTIFIER == _CURRENT_PROCESS_INFORMATION->IDENTIFIER) {
					return;
				}

				// Sets process state
				PROCESS_INFORMATION->PROCESS_STATE = READY;
			}
		} else {

			// Sets error handler preempted process identifier
			_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.PREEMPTED_PROCESS_IDENTIFIER = _CURRENT_PROCESS_INFORMATION->IDENTIFIER;
		}
	}

	// Sets next context to partition default process context
	_CORE_NEXT_CONTEXT = &_CURRENT_PARTITION_INFORMATION->CONTEXT;

	// Sets current process information
	_CURRENT_PARTITION_INFORMATION->CURRENT_PROCESS_INFORMATION = null;
}

// Schedule process in method
static void SCHEDULER_SCHEDULEPROCESSIN(MODULE_INFORMATION_TYPE *MODULE_INFORMATION) {
	priorityqueueENTRY *ENT_PROCESSREADY;
	PROCESS_ID_TYPE PROCESS_IDENTIFIER;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;

	// Verifies current partition information
	if (_CURRENT_PARTITION_INFORMATION == null) {
		return;
	}

	// Verifies partition health monitoring callback running flag
	if (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING) {
		return;
	}

	// Verifies start partition health monitoring callback flag
	if (_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START) {

		// Sets context attributes
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER1 = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE;
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER2 = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER;

		// Prepares partition health monitoring callback context
		PORT_PREPARECONTEXT(&_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT);

		// Resets partition health monitoring callback context system state
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_STATE = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.DEFAULT_SYSTEM_STATE;

		// Sets next context to partition health monitoring callback context
		_CORE_NEXT_CONTEXT = &_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT;

		// Sets partition health monitoring callback running flag
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = true;

		// Sets start partition health monitoring callback flag
		_CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START = false;
		return;
	}

	// Verifies operating mode
	if (_CURRENT_PARTITION_INFORMATION->OPERATING_MODE != NORMAL) {
		return;
	}

	// Verifies error handler running flag
	if (_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING) {
		return;
	}

	// Verifies start error handler flag
	if (_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START) {

		// Sets context attributes
		_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = _CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.SYSTEM_PARTITION_CONTEXT;

		// Prepares partition error handler context
		PORT_PREPARECONTEXT(&_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT);

		// Resets partition error handler context system state
		_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.SYSTEM_STATE = _CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.DEFAULT_SYSTEM_STATE;

		// Sets next context to error handler context
		_CORE_NEXT_CONTEXT = &_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT;

		// Sets error handler running flag
		_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING = true;

		// Sets start error handler flag
		_CURRENT_PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START = false;
		return;
	}

	// Verifies current process information
	if (_CURRENT_PROCESS_INFORMATION != null) {
		return;
	}

	// Verifies lock level
	if (_CURRENT_PARTITION_INFORMATION->LOCK_LEVEL > 0) {
		return;
	}

	// Verifies process ready priority queue
	if (PRIORITYQUEUE_ISEMPTY(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY)) {
		return;
	}

	// Gets process ready priority queue head
	ENT_PROCESSREADY = _CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY.ENT_HEAD;

	// Gets ready process identifier
	PROCESS_IDENTIFIER = (PROCESS_ID_TYPE) ENT_PROCESSREADY->VAL_VALUE;

	// Gets process information
	PROCESS_INFORMATION = &_CURRENT_PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

	// Sets process state
	PROCESS_INFORMATION->PROCESS_STATE = RUNNING;

	// Sets next context to process context
	_CORE_NEXT_CONTEXT = &PROCESS_INFORMATION->CONTEXT;

	// Sets current process information
	_CURRENT_PARTITION_INFORMATION->CURRENT_PROCESS_INFORMATION = PROCESS_INFORMATION;
}

// Start process scheduler method
void SCHEDULER_STARTPROCESSSCHEDULER(RETURN_CODE_TYPE *RETURN_CODE) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	PROCESS_ID_TYPE PROCESS_IDENTIFIER;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;
	INDEX_TYPE SCHEDULE_WINDOW_INDEX;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Verifies process count
	if (_CURRENT_PARTITION_INFORMATION->PROCESS_COUNT == 0) {

		// Sets return code
		*RETURN_CODE = NO_ERROR;
		return;
	}

	// Enters core
	ENTER_CORE();

	// Iterates processes
	for (PROCESS_IDENTIFIER = 0; PROCESS_IDENTIFIER < _CURRENT_PARTITION_INFORMATION->PROCESS_COUNT; PROCESS_IDENTIFIER++) {

		// Gets process information
		PROCESS_INFORMATION = &_CURRENT_PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

		// Verifies process state
		if (PROCESS_INFORMATION->PROCESS_STATE != WAITING) {
			continue;
		}

		// Verifies periodic/aperiodic process
		if (PROCESS_INFORMATION->PROCESS_ATTRIBUTE->PERIOD != APERIODIC_PERIOD_VALUE) {

			// Calculates schedule window index
			SCHEDULE_WINDOW_INDEX = _CURRENT_PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX + 1;

			// Resets schedule window index
			if (SCHEDULE_WINDOW_INDEX >= _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW_SIZE) {
				SCHEDULE_WINDOW_INDEX = 0;
			}

			// Period start search loop
			while (_CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[SCHEDULE_WINDOW_INDEX].PERIOD_START == false) {

				// Moves schedule window index
				SCHEDULE_WINDOW_INDEX++;

				// Resets schedule window index
				if (SCHEDULE_WINDOW_INDEX >= _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW_SIZE) {
					SCHEDULE_WINDOW_INDEX = 0;
				}
			}

			// Sets release time
			if (SCHEDULE_WINDOW_INDEX <= _CURRENT_PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX) {
				PROCESS_INFORMATION->RELEASE_TIME = MODULE_INFORMATION->NEXT_MAJOR_FRAME_START + _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[SCHEDULE_WINDOW_INDEX].START + PROCESS_INFORMATION->DELAY_TIME;
			} else {
				PROCESS_INFORMATION->RELEASE_TIME = MODULE_INFORMATION->MAJOR_FRAME_START + _CURRENT_PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[SCHEDULE_WINDOW_INDEX].START + PROCESS_INFORMATION->DELAY_TIME;
			}

			// Sets deadline time
			if (PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY != INFINITE_TIME_VALUE) {
				PROCESS_INFORMATION->DEADLINE_TIME = PROCESS_INFORMATION->RELEASE_TIME + PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY;
			} else {
				PROCESS_INFORMATION->DEADLINE_TIME = INFINITE_TIME_VALUE;
			}

			// Sets process state
			PROCESS_INFORMATION->PROCESS_STATE = WAITING;

			// Sets wait and wake time
			PROCESS_INFORMATION->WAIT_TIME = CLOCK_GETSYSTEMTIME();
			PROCESS_INFORMATION->WAKE_TIME = INFINITE_TIME_VALUE;

			// Fills process waiting timeout priority queue entry
			PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->RELEASE_TIME;
			PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

			// Enqueues process waiting timeout priority queue entry
			PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT, &PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT);
		} else {

			// Verifies delay time
			if (PROCESS_INFORMATION->DELAY_TIME == 0) {

				// Sets release time
				PROCESS_INFORMATION->RELEASE_TIME = CLOCK_GETSYSTEMTIME();

				// Sets deadline time
				if (PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY != INFINITE_TIME_VALUE) {
					PROCESS_INFORMATION->DEADLINE_TIME = PROCESS_INFORMATION->RELEASE_TIME + PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY;
				} else {
					PROCESS_INFORMATION->DEADLINE_TIME = INFINITE_TIME_VALUE;
				}

				// Sets process state
				PROCESS_INFORMATION->PROCESS_STATE = READY;

				// Fills process ready priority queue entry
				PROCESS_INFORMATION->ENT_PROCESSREADY.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->CURRENT_PRIORITY;
				PROCESS_INFORMATION->ENT_PROCESSREADY.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

				// Enqueues process ready priority queue entry
				PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSREADY, &PROCESS_INFORMATION->ENT_PROCESSREADY);

				// Verifies deadline time
				if (PROCESS_INFORMATION->DEADLINE_TIME != INFINITE_TIME_VALUE) {

					// Fills process deadline priority queue entry
					PROCESS_INFORMATION->ENT_PROCESSDEADLINE.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->DEADLINE_TIME;
					PROCESS_INFORMATION->ENT_PROCESSDEADLINE.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

					// Enqueues process deadline priority queue entry
					PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSDEADLINE, &PROCESS_INFORMATION->ENT_PROCESSDEADLINE);
				}
			} else {

				// Sets release time
				PROCESS_INFORMATION->RELEASE_TIME = CLOCK_GETSYSTEMTIME() + PROCESS_INFORMATION->DELAY_TIME;

				// Sets deadline time
				if (PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY != INFINITE_TIME_VALUE) {
					PROCESS_INFORMATION->DEADLINE_TIME = PROCESS_INFORMATION->RELEASE_TIME + PROCESS_INFORMATION->PROCESS_ATTRIBUTE->TIME_CAPACITY;
				} else {
					PROCESS_INFORMATION->DEADLINE_TIME = INFINITE_TIME_VALUE;
				}

				// Sets process state
				PROCESS_INFORMATION->PROCESS_STATE = WAITING;

				// Sets wait and wake time
				PROCESS_INFORMATION->WAIT_TIME = CLOCK_GETSYSTEMTIME();
				PROCESS_INFORMATION->WAKE_TIME = INFINITE_TIME_VALUE;

				// Fills process waiting timeout priority queue entry
				PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT.PRI_PRIORITY = (priorityqueuePRIORITY) PROCESS_INFORMATION->RELEASE_TIME;
				PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT.VAL_VALUE = (priorityqueueVALUE) PROCESS_INFORMATION->IDENTIFIER;

				// Enqueues process waiting timeout priority queue entry
				PRIORITYQUEUE_ENQUEUE(&_CURRENT_PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT, &PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT);
			}
		}
	}

	// Sets current process information
	_CURRENT_PARTITION_INFORMATION->CURRENT_PROCESS_INFORMATION = null;

	// Yields
	PORT_YIELD();

	// Sets return code
	*RETURN_CODE = NO_ERROR;

	// Exits core
	EXIT_CORE();
}

// Scheduler
void SCHEDULER(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

#ifdef MEASURE
	// Verifies operating mode
	if (MODULE_INFORMATION->OPERATING_MODE == IDLE) {

		// Sets context
		_CORE_CURRENT_CONTEXT = &MODULE_INFORMATION->CONTEXT;
		return;
	}
#endif

	// Handles processes events
	SCHEDULER_HANDLEPROCESSESEVENTS(MODULE_INFORMATION, _CORE_CURRENT_CONTEXT->DEFAULT_SYSTEM_STATE);

	// Schedules process out
	SCHEDULER_SCHEDULEPROCESSOUT(MODULE_INFORMATION);

	// Schedules partition out
	SCHEDULER_SCHEDULEPARTITIONOUT(MODULE_INFORMATION);

	// Schedules partition in
	if (SCHEDULER_SCHEDULEPARTITIONIN(MODULE_INFORMATION)) {

		// Handles processes events in new partition
		SCHEDULER_HANDLEPROCESSESEVENTS(MODULE_INFORMATION, _CORE_NEXT_CONTEXT->DEFAULT_SYSTEM_STATE);

		// Schedules process out in new partition
		SCHEDULER_SCHEDULEPROCESSOUT(MODULE_INFORMATION);
	}

	// Schedules process in
	SCHEDULER_SCHEDULEPROCESSIN(MODULE_INFORMATION);

	// Verifies context transition
	if (_CORE_NEXT_CONTEXT != null) {

#if defined(TRACK)
		// Tracks context switch
		CONSOLE_PRINTF("%u CS %d %d\n", TRACK_READ(), _CORE_CURRENT_CONTEXT->IDENTIFIER, _CORE_NEXT_CONTEXT->IDENTIFIER);
#endif

		// Sets current context
		_CORE_CURRENT_CONTEXT = _CORE_NEXT_CONTEXT;

		// Clears next context
		_CORE_NEXT_CONTEXT = null;
	}
}

// Tick method
void TICK(void) {
	MODULE_INFORMATION_TYPE *MODULE_INFORMATION;
	PARTITION_ID_TYPE PARTITION_IDENTIFIER;
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;

	// Gets module information
	MODULE_INFORMATION = _CORE_MODULE_INFORMATION;

	// Ticks clock window
	CLOCK_TICKWINDOW();

	// Verifies major frame time
	if (MODULE_INFORMATION->MAJOR_FRAME_TIME >= MODULE_INFORMATION->MODULE_CONFIGURATION->MAJORFRAME_DURATION) {

		// Ticks clock major frame
		CLOCK_TICKMAJORFRAME();

		// Iterates partitions
		for (PARTITION_IDENTIFIER = 0; PARTITION_IDENTIFIER < MODULE_INFORMATION->PARTITION_COUNT; PARTITION_IDENTIFIER++) {

			// Gets partition information
			PARTITION_INFORMATION = &MODULE_INFORMATION->PARTITION_INFORMATION[PARTITION_IDENTIFIER];

			// Removes priority queue entries
			PRIORITYQUEUE_REMOVE(&PARTITION_INFORMATION->ENT_PARTITIONREADY);

			// Resets partition schedule
			PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX = 0;

			// Verifies partition operating mode
			if (PARTITION_INFORMATION->OPERATING_MODE != IDLE) {

				// Fills partition ready priority queue entry
				PARTITION_INFORMATION->ENT_PARTITIONREADY.PRI_PRIORITY = (priorityqueuePRIORITY) PARTITION_INFORMATION->PARTITION_CONFIGURATION->PARTITION_CONFIGURATION_SCHEDULE->SCHEDULE_WINDOW[PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX].START;
				PARTITION_INFORMATION->ENT_PARTITIONREADY.VAL_VALUE = (priorityqueueVALUE) PARTITION_INFORMATION->IDENTIFIER;

				// Enqueues partition ready priority queue entry
				PRIORITYQUEUE_ENQUEUE(&MODULE_INFORMATION->REC_PARTITIONREADY, &PARTITION_INFORMATION->ENT_PARTITIONREADY);
			}
		}
	}

	// Calls scheduler
	SCHEDULER();
}
