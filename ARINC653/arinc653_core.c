// ARINC653 includes
#include "arinc653_core.h"

// System information
SYSTEM_INFORMATION_TYPE SYSTEM_INFORMATION;

// Module information
MODULE_INFORMATION_TYPE MODULE_INFORMATION;

// Current context - Context of the running task
CONTEXT_TYPE *CURRENT_CONTEXT;

// Current context - Context to be reached after the scheduler completes
CONTEXT_TYPE *NEXT_CONTEXT;

// Startup core method
void STARTUP_CORE(void) {

	// Initializes current context
	CURRENT_CONTEXT = null;

	// Initializes next context
	NEXT_CONTEXT = null;
}

// Enter core method
void ENTER_CORE(void) {

	// Enters core
	PORT_ENTERCORE();

	// Verifies current context
	if (CURRENT_CONTEXT != null) {

		// Verifies current context core depth
		if (CURRENT_CONTEXT->CORE_DEPTH == 0) {

			// Sets current context system state
			CURRENT_CONTEXT->SYSTEM_STATE = SYSTEMSTATE_OPERATINGSYSTEM;
		}

		// Increases current context core depth
		CURRENT_CONTEXT->CORE_DEPTH++;
	}
}

// Exit core method
void EXIT_CORE(void) {

	// Verifies current context
	if (CURRENT_CONTEXT != null) {

		// Verifies current context core depth
		if (CURRENT_CONTEXT->CORE_DEPTH > 0) {

			// Decreases current context core depth
			CURRENT_CONTEXT->CORE_DEPTH--;
		}

		// Verifies current context core depth
		if (CURRENT_CONTEXT->CORE_DEPTH == 0) {

			// Resets current context system state
			CURRENT_CONTEXT->SYSTEM_STATE = CURRENT_CONTEXT->DEFAULT_SYSTEM_STATE;

			// Exits core
			PORT_EXITCORE();
		}
	}
}

// Process information initialization method
void INITIALIZE_PROCESS_INFORMATION(PARTITION_ID_TYPE PARTITION_IDENTIFIER, PROCESS_ID_TYPE PROCESS_IDENTIFIER) {
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;
	PROCESS_INFORMATION_TYPE *PROCESS_INFORMATION;

	// Gets partition information
	PARTITION_INFORMATION = &MODULE_INFORMATION.PARTITION_INFORMATION[PARTITION_IDENTIFIER];

	// Gets process information
	PROCESS_INFORMATION = &PARTITION_INFORMATION->PROCESS_INFORMATION[PROCESS_IDENTIFIER];

	// (Re)initializes information
	PROCESS_INFORMATION->PROCESS_ATTRIBUTE = null;
	PROCESS_INFORMATION->PROCESS_CONFIGURATION = null;
	PROCESS_INFORMATION->IDENTIFIER = INVALID_IDENTIFIER;
	PROCESS_INFORMATION->CURRENT_PRIORITY = 0;
	PROCESS_INFORMATION->PROCESS_STATE = DORMANT;
	PROCESS_INFORMATION->DELAY_TIME = INFINITE_TIME_VALUE;
	PROCESS_INFORMATION->RELEASE_TIME = INFINITE_TIME_VALUE;
	PROCESS_INFORMATION->DEADLINE_TIME = INFINITE_TIME_VALUE;
	PROCESS_INFORMATION->WAIT_TIME = INFINITE_TIME_VALUE;
	PROCESS_INFORMATION->WAKE_TIME = INFINITE_TIME_VALUE;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps context information while reinitializing to avoid reallocation
		PROCESS_INFORMATION->CONTEXT.IDENTIFIER = null;
		PROCESS_INFORMATION->CONTEXT.STACK_BOTTOM = null;
		PROCESS_INFORMATION->CONTEXT.STACK_TOP = null;
		PROCESS_INFORMATION->CONTEXT.PORT_CONTEXT = null;
		PROCESS_INFORMATION->CONTEXT.CORE_DEPTH = null;
		PROCESS_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
		PROCESS_INFORMATION->CONTEXT.ENTRY_POINT = null;
		PROCESS_INFORMATION->CONTEXT.RETURN_POINT = null;
		PROCESS_INFORMATION->CONTEXT.PARAMETER1 = null;
		PROCESS_INFORMATION->CONTEXT.PARAMETER2 = null;
	}

	// Verifies partition initialized flag
	if (PARTITION_INFORMATION->INITIALIZED) {

		// Removes priority queue entries
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSREADY);
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSDEADLINE);
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT);
		PRIORITYQUEUE_REMOVE(&PROCESS_INFORMATION->ENT_PROCESSWAITING_RESOURCE);
	}

	// (Re)initializes priority queue entries
	PRIORITYQUEUE_INITIALIZEENTRY(&PROCESS_INFORMATION->ENT_PROCESSREADY);
	PRIORITYQUEUE_INITIALIZEENTRY(&PROCESS_INFORMATION->ENT_PROCESSDEADLINE);
	PRIORITYQUEUE_INITIALIZEENTRY(&PROCESS_INFORMATION->ENT_PROCESSWAITING_TIMEOUT);
	PRIORITYQUEUE_INITIALIZEENTRY(&PROCESS_INFORMATION->ENT_PROCESSWAITING_RESOURCE);

	// (Re)initializes information
	PROCESS_INFORMATION->SUSPENDED = false;
	PROCESS_INFORMATION->SUSPENDED_TIMEOUT = false;

	// -------------------- OPTIONAL MODULES START --------------------

	// -------------------- BUFFER --------------------

	// (Re)initializes buffer information
	PROCESS_INFORMATION->BUFFER_SEND_ADDRESS = null;
	PROCESS_INFORMATION->BUFFER_SEND_LENGTH = 0;
	PROCESS_INFORMATION->BUFFER_RECEIVE_ADDRESS = null;
	PROCESS_INFORMATION->BUFFER_RECEIVE_LENGTH = null;

	// -------------------- OPTIONAL MODULES END --------------------
}

// Partition information initialization method
void INITIALIZE_PARTITION_INFORMATION(PARTITION_ID_TYPE PARTITION_IDENTIFIER, BOOLEAN_TYPE REINITIALIZING) {
	PARTITION_INFORMATION_TYPE *PARTITION_INFORMATION;
	PROCESS_ID_TYPE PROCESS_IDENTIFIER;

	// Gets partition information
	PARTITION_INFORMATION = &MODULE_INFORMATION.PARTITION_INFORMATION[PARTITION_IDENTIFIER];

	// Verifies reinitializing flag
	if (!REINITIALIZING) {

		// Initializes initialized flag
		PARTITION_INFORMATION->INITIALIZED = false;
	}

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps basic partition information while reinitializing
		PARTITION_INFORMATION->PARTITION_ATTRIBUTE = null;
		PARTITION_INFORMATION->PARTITION_CONFIGURATION = null;
		PARTITION_INFORMATION->IDENTIFIER = INVALID_IDENTIFIER;
		PARTITION_INFORMATION->OPERATING_MODE = IDLE;
		PARTITION_INFORMATION->START_CONDITION = NORMAL_START;
	}

	// (Re)initializes information
	PARTITION_INFORMATION->LOCK_LEVEL = 0;
	PARTITION_INFORMATION->HEALTHMONITORING_PARTITION_RESTART = false;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps heap information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->REC_HEAP.PTR_POINTER = null;
		PARTITION_INFORMATION->REC_HEAP.SIZ_SIZE = null;
		PARTITION_INFORMATION->REC_HEAP.SIZ_FULL = null;

		// Keeps context information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->CONTEXT.IDENTIFIER = null;
		PARTITION_INFORMATION->CONTEXT.STACK_BOTTOM = null;
		PARTITION_INFORMATION->CONTEXT.STACK_TOP = null;
		PARTITION_INFORMATION->CONTEXT.PORT_CONTEXT = null;
		PARTITION_INFORMATION->CONTEXT.CORE_DEPTH = null;
		PARTITION_INFORMATION->CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
		PARTITION_INFORMATION->CONTEXT.ENTRY_POINT = null;
		PARTITION_INFORMATION->CONTEXT.RETURN_POINT = null;
		PARTITION_INFORMATION->CONTEXT.PARAMETER1 = null;
		PARTITION_INFORMATION->CONTEXT.PARAMETER2 = null;
	}

	// (Re)initializes information
	PARTITION_INFORMATION->PROCESS_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps process information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->PROCESS_INFORMATION = null;
	} else {

		// Iterates process entries
		for (PROCESS_IDENTIFIER = 0; PROCESS_IDENTIFIER < PARTITION_INFORMATION->PARTITION_CONFIGURATION->MAXIMUM_PROCESS_COUNT; PROCESS_IDENTIFIER++) {

			// Reinitializes process information
			INITIALIZE_PROCESS_INFORMATION(PARTITION_IDENTIFIER, PROCESS_IDENTIFIER);
		}
	}

	// (Re)initializes information
	PARTITION_INFORMATION->CURRENT_PROCESS_INFORMATION = null;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.EXISTS = false;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.ENTRY_POINT = null;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.STACK_SIZE = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps context information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.IDENTIFIER = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.STACK_BOTTOM = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.STACK_TOP = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.PORT_CONTEXT = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.CORE_DEPTH = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.ENTRY_POINT = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.RETURN_POINT = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.PARAMETER1 = null;
		PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.CONTEXT.PARAMETER2 = null;
	}

	// (Re)initializes information
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.SYSTEM_PARTITION_CONTEXT = false;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.START = false;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.STOP = false;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.RUNNING = false;
	PARTITION_INFORMATION->ERRORHANDLER_INFORMATION.PREEMPTED_PROCESS_IDENTIFIER = INVALID_IDENTIFIER;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps health monitoring callback information while reinitializing
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.EXISTS = false;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ENTRY_POINT = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STACK_SIZE = 0;

		// Keeps context information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.STACK_BOTTOM = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.STACK_TOP = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.CORE_DEPTH = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.ENTRY_POINT = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.RETURN_POINT = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER1 = null;
		PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER2 = null;
	}

	// (Re)initializes information
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT = false;
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.START = false;
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = false;
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE = (SYSTEM_STATE_TYPE) null;
	PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) null;
	PARTITION_INFORMATION->SCHEDULE_WINDOW_INDEX = 0;

	// Verifies partition initialized flag
	if (PARTITION_INFORMATION->INITIALIZED) {

		// Removes priority queue entries
		PRIORITYQUEUE_REMOVE(&PARTITION_INFORMATION->ENT_PARTITIONREADY);
	}

	// (Re)initializes priority queue entries
	PRIORITYQUEUE_INITIALIZEENTRY(&PARTITION_INFORMATION->ENT_PARTITIONREADY);

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Starts up priority queues
		PRIORITYQUEUE_STARTUP(&PARTITION_INFORMATION->REC_PROCESSREADY, true, false);
		PRIORITYQUEUE_STARTUP(&PARTITION_INFORMATION->REC_PROCESSDEADLINE, true, true);
		PRIORITYQUEUE_STARTUP(&PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT, true, true);
	} else {

		// Clears priority queues
		PRIORITYQUEUE_CLEAR(&PARTITION_INFORMATION->REC_PROCESSREADY, true, false);
		PRIORITYQUEUE_CLEAR(&PARTITION_INFORMATION->REC_PROCESSDEADLINE, true, true);
		PRIORITYQUEUE_CLEAR(&PARTITION_INFORMATION->REC_PROCESSWAITING_TIMEOUT, true, true);
	}

	// (Re)initializes information
	PARTITION_INFORMATION->ERROR_STATUS_COUNT = 0;
	PARTITION_INFORMATION->NEXT_ERROR_STATUS_INDEX = 0;

	// -------------------- OPTIONAL MODULES START --------------------

	// -------------------- SAMPLING PORT --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->SAMPLINGPORT_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps sampling port information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->SAMPLINGPORT_INFORMATION = null;
	}

	// -------------------- QUEUING PORT --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->QUEUINGPORT_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps queuing port information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->QUEUINGPORT_INFORMATION = null;
	}

	// -------------------- BUFFER --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->BUFFER_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps buffer information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->BUFFER_INFORMATION = null;
	}

	// -------------------- BLACKBOARD --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->BLACKBOARD_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps blackboard information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->BLACKBOARD_INFORMATION = null;
	}

	// -------------------- SEMAPHORE --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->SEMAPHORE_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps semaphore information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->SEMAPHORE_INFORMATION = null;
	}

	// -------------------- EVENT --------------------

	// (Re)initializes information
	PARTITION_INFORMATION->EVENT_COUNT = 0;

	// Verifies partition initialized flag
	if (!PARTITION_INFORMATION->INITIALIZED) {

		// Keeps event information while reinitializing to avoid reallocation
		PARTITION_INFORMATION->EVENT_INFORMATION = null;
	}

	// -------------------- OPTIONAL MODULES END --------------------
}

// Module information initialization method
void INITIALIZE_MODULE_INFORMATION(void) {
	PARTITION_ID_TYPE PARTITION_IDENTIFIER;

	// (Re)initializes information
	// MODULE_INFORMATION.MODULE_CONFIGURATION = null; // Must be already initialized
	MODULE_INFORMATION.OPERATING_MODE = COLD_START;
	MODULE_INFORMATION.CONTEXT.IDENTIFIER = null;
	MODULE_INFORMATION.CONTEXT.STACK_BOTTOM = null;
	MODULE_INFORMATION.CONTEXT.STACK_TOP = null;
	MODULE_INFORMATION.CONTEXT.PORT_CONTEXT = null;
	MODULE_INFORMATION.CONTEXT.CORE_DEPTH = null;
	MODULE_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
	MODULE_INFORMATION.CONTEXT.ENTRY_POINT = null;
	MODULE_INFORMATION.CONTEXT.RETURN_POINT = null;
	MODULE_INFORMATION.CONTEXT.PARAMETER1 = null;
	MODULE_INFORMATION.CONTEXT.PARAMETER2 = null;
	MODULE_INFORMATION.CONTEXT.DEFAULT_SYSTEM_STATE = (SYSTEM_STATE_TYPE) null;
	MODULE_INFORMATION.CONTEXT.SYSTEM_STATE = (SYSTEM_STATE_TYPE) null;
	MODULE_INFORMATION.PARTITION_COUNT = 0;

	// Iterates partition entries
	for (PARTITION_IDENTIFIER = 0; PARTITION_IDENTIFIER < MODULE_INFORMATION.MODULE_CONFIGURATION->MAXIMUM_PARTITION_COUNT; PARTITION_IDENTIFIER++) {

		// (Re)initializes partition information
		INITIALIZE_PARTITION_INFORMATION(PARTITION_IDENTIFIER, false);
	}

	// (Re)initializes information
	MODULE_INFORMATION.CURRENT_PARTITION_INFORMATION = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.EXISTS = false;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.ENTRY_POINT = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.STACK_SIZE = 0;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.IDENTIFIER = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.STACK_BOTTOM = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.STACK_TOP = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PORT_CONTEXT = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.CORE_DEPTH = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.SYSTEM_PARTITION_CONTEXT = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.ENTRY_POINT = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.RETURN_POINT = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER1 = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.CONTEXT.PARAMETER2 = null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_PARTITION_CONTEXT = false;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.START = false;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.STOP = false;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.RUNNING = false;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE = (SYSTEM_STATE_TYPE) null;
	MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER = (ERROR_IDENTIFIER_TYPE) null;
	MODULE_INFORMATION.MAJOR_FRAME_START = INFINITE_TIME_VALUE;
	MODULE_INFORMATION.MAJOR_FRAME_TIME = INFINITE_TIME_VALUE;
	MODULE_INFORMATION.NEXT_MAJOR_FRAME_START = INFINITE_TIME_VALUE;

	// Starts up priority queues
	PRIORITYQUEUE_STARTUP(&MODULE_INFORMATION.REC_PARTITIONREADY, true, true);
}

// System information initialization method
void INITIALIZE_SYSTEM_INFORMATION(void) {

	// (Re)initializes information
	// SYSTEM_INFORMATION.SYSTEM_CONFIGURATION = null; // Must be already initialized
	SYSTEM_INFORMATION.REC_HEAP.PTR_POINTER = null;
	SYSTEM_INFORMATION.REC_HEAP.SIZ_SIZE = null;
	SYSTEM_INFORMATION.REC_HEAP.SIZ_FULL = null;
	SYSTEM_INFORMATION.NEXT_CONTEXT_IDENTIFIER = 2; // Identifier 1 is reserved for module default partition context
}

// Module health monitoring callback return point
void RETURNPOINT_MODULE_HEALTHMONITORINGCALLBACK(void) {
	SYSTEM_STATE_TYPE SYSTEM_STATE;
	ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER;

	// Enters core
	ENTER_CORE();

	// Gets system state and error identifier
	SYSTEM_STATE = MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE;
	ERROR_IDENTIFIER = MODULE_INFORMATION.HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER;

	// Exits core
	EXIT_CORE();

	// Runs module error action
	RUN_MODULE_ERROR_ACTION(true, true, SYSTEM_STATE, ERROR_IDENTIFIER);

	// Stops module health monitoring callback
	STOP_MODULE_HEALTHMONITORINGCALLBACK();

	// Loops forever - Should never be reached
	while (true) {
	}
}

// Partition health monitoring callback return point
void RETURNPOINT_PARTITION_HEALTHMONITORINGCALLBACK(void) {
	SYSTEM_STATE_TYPE SYSTEM_STATE;
	ERROR_IDENTIFIER_TYPE ERROR_IDENTIFIER;

	// Enters core
	ENTER_CORE();

	// Gets system state and error identifier
	SYSTEM_STATE = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.SYSTEM_STATE;
	ERROR_IDENTIFIER = _CURRENT_PARTITION_INFORMATION->HEALTHMONITORINGCALLBACK_INFORMATION.ERROR_IDENTIFIER;

	// Exits core
	EXIT_CORE();

	// Runs partition error action
	RUN_PARTITION_ERROR_ACTION(true, true, SYSTEM_STATE, ERROR_IDENTIFIER);

	// Stops partition health monitoring callback
	STOP_PARTITION_HEALTHMONITORINGCALLBACK();

	// Loops forever - Should never be reached
	while (true) {
	}
}

// Partition error handler return point
void RETURNPOINT_PARTITIONERRORHANDLER(void) {

	// Stops error handler
	STOP_SELF();
}

// Partition default process return point
void RETURNPOINT_PARTITIONDEFAULTPROCESS(void) {

	// Loops forever
	while (true) {
	}
}

// Process return point
void RETURNPOINT_PROCESS(void) {

	// Stops process
	STOP_SELF();
}
